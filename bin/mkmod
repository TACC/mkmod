#!/bin/bash

                   # DO NOT MODIFY format "MKMOD_version=<ver>  # VERSION SOURCE"
MKMOD_VERSION=1.0  # VERSION SOURCE makefile extracts version from this line


MKMOD_HELP=$(sed 's/^#//' <<'EOF'
#  mkmod builds & inserts a modulefile in $HOME/modulefiles.
#
#  The minimal work a user must do is export 3 variables and call mkmod.
#
#  e.g.  NAME=tau
#        VER=2.26.2p1
#        TOPDIR=$HOME/$NAME
#      
#        export NAME VER TOPDIR
#
#        mkmod
#
#  NAME   is the name of the package, less the version number.
#  VER    is the version of the package, usually found in the package name.
#  TOPDIR is the "top level directory" of the package (e.g. $HOME/tau-2.26.2p1)
#
#       Set MODULEFILE_DIR if you don't want to use $HOME/modulefiles.
#
#  
#  FEATURES - module creation
#       * Auto sets module name to my_<name>/<ver>
#       * Auto sets MY_<NAME>_<dir> Env Vars (dir=DOC/LIB/SHR/BIN/INC/DAT/EXM/TUT/TOL/DIR)
#                                            (these are called distro_dirs)
#                                            (use PREFIX=<whatever> in lieu of MY_/my_)
#       * Auto sets PATH/LD_LIB_PATH/MANPATH/PYTHONPATH
#       * Auto sets prereq (to whatever comp/mpi is loaded) and sets family
#       * Auto creates help_message: lists distro_dirs  & paths env var names & vals.
#                                    lists module command and pkg version.
#       * HELP_MESSAGE (env var)     included in help_message (e.g. loader instructions)
#       * help_message (file)        if found, includes file (does variable replacement).
#                                    (file is sourced if "here file" syntax observed)
#       * AUTO_HELP    (env var)     set to "none" or list one or more of set:
#                                    (dirs, paths, envs, module, version).
#  
#  FEATURES - module setup
#       * Sets up $HOME/modulefiles directory (mkdir, perms, etc.)
#       * Sets up "module use $HOME/modulefiles" in $HOME/.bashrc
#  
#  FEATURES - control and instrumentation
#       Defaults can be changed by these Environment Variables
#  
#       1.) MODULEFILES_DIR          (default= $HOME/modulefiles )
#       2.) GROUP_ACCESS             (if set, allow primary group access)
#       3.) GROUP                    (required for non-primary group)
#
#       4.) COMPILER_PREREQ          (auto default= loaded compiler)
#       5.)      MPI_PREREQ          (auto default= loaded MPI)
#       6.)     AUTO_PREREQ          (set to "none" avoid auto setting compiler/mpi prereqs.)
#       7.)          PREREQ          (sets prereqs -- space separated list)
#
#       8.) PREFIX                   (default= MY_|my_)
#       9.) FAMILY                   (default= NAME, set to "" for no family)
#      10.) HELP_FILE                (default= $TOPDIR/modules_help, use this var
#                                              to set path and name for your own help file.)
#      11.) WHATIS_FILE              (default= $TOPDIR/modules_whatis, use this var
#                                              to set path and name for your own whatis file.)
#      12.) USE_BASHRC               (if "none", no .bashrc check-- e.g. for RPMS)
#      13.) MKMOD_DEBUG              (if set, modulefile goes to std out)
#
#  
#       PATHS -- RELATIVE to TOPDIR
#  
#           topdir_path_list         (e.g. ="x86_64/bin")
#           topdir_ldpath_list       (e.g. ="x86_64/libraries/linpack")
#           topdir_manpath_list      (e.g. ="man linpack/man otherpkg/man")
#           topdir_pythonpath_list   (e.g. ="share/pkgs/python")
#  
#       PATHS -- FULL
#  
#           path_list                (e.g. path_list="/sbin /home1/1234/charles/bin")
#           ldpath_list              (e.g. ldpath_list="/opt/apps/papi/5.6.0/lib")
#  
#       PREREQUISITES -- must be loaded
#  
#           PREREQ                   (space separated list)
#  
#  
#       WHATIS   (not automatic)
#  
#           WHATIS                   (@-separated list. e.g.
#                                     WHATIS="Name: PETSc @ Version: 3.8 @ Category: lib")
#  
#      ENVIROMENT -- VARIABLES       (also displayed in the help message)
#  
#          ENV1="<val1>"             (e.g. ENV1="TAU=$TOPDIR/x86_64/bin")
#          ENV2="<val2>"             (e.g. ENV2="GET_TIME_OF_DAY:PAPI_TOT_CYC:PAPI_L2_LDM")
#          ENV3="<val3>"
#  
#      COMMANDS -- LUA statements
#  
#          CMD1="<cmd1>"             (e.g.LMOD CMD1="conflict(\"boost\",\"boost-mpi\")" )
#          CMD2="<cmd2>"             (e.g.LMOD CMD2="load(\"hdf5\")" )
#
#          CMD1="<cmd1>"             (e.g.TMOD CMD1="conflict boost boost-mpi" )
#          CMD2="<cmd2>"             (e.g.TMOD CMD2="load  hdf5" )
#  
#  COMPONENTS - order
#    1.) Help Message (see default, or contents of help_message file)
#    2.) whatis       (none by default, use WHATIS env var)
#    3.) family       (default $NAME_sml, use FAMILY env var)
#    4.) prereq's     (default=loaded Compiler/MPI, use COMPILER_PREREQ|MPI_PREREQ)
#    5.) prereq's     (Explicitly set)
#    6.) local topdir (definition for $TOPDIR)
#    7.) prepends     (from topdir_path|ldpath|manpath|pythonpath_list) 
#    8.) prepends     (from full path path|ldpath|manpath|pythonpath_list) 
#    9.) setenv       (from ENV1, ENV2, ..., ENV30 )
#   10.) LUA cmds     (from COMMAND1, COMMAND2, ..., COMMAND30)
#
#  TUTORIAL - module (LMOD)  details
#     tinyurl.com/chpc-2017-tools  (download CHPC_2017_lmod_28.pdf)
#
#                                                 author:  Kent Milfeld 3/7/2018
#  ------

EOF
)

# New Features  Version 1.0
#     TMOD support (by FLAVOR: lmod or tmod). 3/29/2018
#     Explicitly defined prereqs. support 3/29/2018
#     WHATIS_FILE support 3/29/2018
#
# TODO -- still has some TACCism that should be generalized (e.g. $WORK directory)
#tmod https://github.com/cea-hpc/modules/blob/master/doc/paper/MC2_whitney_paper.pdf

t_divider="  "
l_divider="--"

USAGE='
  USAGE: mkmod [-h|--help]

         NAME, VER and TOPDIR must be defined and exported.
  ---------------------------------------------------------
'

  if [[ $1 == "-h" ]] || [[ $1 == "--help" ]]; then
     echo "$USAGE"
     echo "$MKMOD_HELP"
     exit 0
  fi

  if [[ $1 == "-v" ]] || [[ $1 == "--version" ]]; then
     echo "VERSION=$MKMOD_VERSION"
     exit 0
  fi


  if [[ ! "$NAME"    =~ [^[:space:]]  ]] ||
     [[ ! "$VER"     =~ [^[:space:]]  ]] ||
     [[ ! "$TOPDIR"  =~ [^[:space:]]  ]] ;  then

     echo " $USAGE "
     exit 1 
  fi

                            # default help_message file is $TOPDIR/modules_help
  [[ ! "$HELP_FILE"  =~ [^[:space:]]  ]] && HELP_FILE=$TOPDIR/modules_help

                            # look for these compilers (names) as loaded compiler modules
  compilers=(intel gcc llvm clang open64 pgi ibmcmp)
 #compilers=(intel clang)
  MPIs=(impi mvapich2 openmpi mpich)

#############BEG--v      DETERMINE if using LMOD OR TMOD
if [[ ! $MKMOD_FLAVOR =~ [^[:space:]] ]]; then
       # Determine whether to use tmod or lmod.
       # modver=(`module --version 2>&1`)    #Uh tmodule 3.x displays version and returns "1" !
       # if [[ ! $? == "0" ]]; then
       # Use MODULESHOME variable as indicator
  if [[ ! "$MODULESHOME" =~ [^[:space:]]  ]]; then
   echo "  ->  ERROR: Found neither Tmod (TCL) nor Lmod (Lua) to exist on this machine."
   echo "  ->         mkmod supports only these flavors of modules."
   echo "  ->         Used the existence of \$MODULEHOME to determine existence of environment modules."
   echo "  ->         You can set MKMOD_FLAVOR to either Tmod or Lmod to override | force creation."
   exit 1
  else
       # Assume tmod.  If --version shows Lau, then assume lmod
   FLAVOR=tmod
   modver=(`module --version 2>&1`)
   status=$?
   if [[  $status != "0" ]] && [[  $status != "1" ]]; then
     echo "  -> ERROR: \"module --version\" didn't work." 
     echo "  ->         You can set MKMOD_FLAVOR to either Tmod or Lmod to override | force creation."
     exit 0
   fi
   [[ ${modver[@]} =~ "Lua" ]] && FLAVOR=lmod

   echo ""
   echo "  -> Will create a modulefile for $NAME with the $FLAVOR flavor of modules."
  fi

else
  FLAVOR=$( echo $MKMOD_FLAVOR | tr '[:upper:]' '[:lower:]' )
  if [[ $FLAVOR == "lmod"  ]] || [[ $FLAVOR == "tmod"  ]] ; then
     echo "  -> Will create $FLAVOR flavored modulefile (determined by \$MKMOD_FLAVOR)."
  else
     echo "  -> ERROR: MKMOD_FLAVOR must be either Lmod or Tmod (case insensitive)."
     echo "  ->        Found $MKMOD_FLAVOR."
     exit 2
  fi
fi
#############END--^      Determine if using LMOD OR TMOD

#############BEG--v      CREATE MODULEFILE

 ##BEG--v  Modulefile Prep

  #   IF TOPDIR doesn't exist -- exit

  echo ""
  echo "  -> mkmod MODULEFILE CREATION:"
  if [[ ! -d $TOPDIR ]]; then
     echo "  -> ERROR: Could not find directory \$TOPDIR: $TOPDIR"
     echo "  ->        Application must be installed in \$TOPDIR before executing mkmod."
     exit 2
  else
     echo "  -> Found \$TOPDIR directory: $TOPDIR"
  fi

  #                          #Optional Values,  TACC Staff agree on these defaults
  
                             # Best to have a prefix so as not to confuse
                             # with production version
                             # (e.g. ml intel/18.0.0    gamess #production version)
                             # (e.g. ml intel/18.0.0 my_gamess #personal   version)
  
  #https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
                        #PREFIX NOT DEFINE, (does not include "")
  if [[ -z "${PREFIX+x}" ]]; then
     PREFIX_sml=my_
     PREFIX_cap=MY_
  else                    #USER-DEFINED PREFIX (may include "" -- which means NO prefix)
     PREFIX_cap=$( echo $PREFIX | tr '[:lower:]' '[:upper:]' )
     PREFIX_sml=$( echo $PREFIX | tr '[:upper:]' '[:lower:]' )
  fi

  echo "  -> Prefix for module is \"$PREFIX_sml\". (Set PREFIX=\"\" for none.)"

  
  if [[ ! "$MODULEFILES_DIR"  =~ [^[:space:]]  ]]; then

     MODULEFILES_DIR=$HOME/modulefiles      # Default place to put modulefiles
  fi   

  DIR_ABOVE=$(dirname $MODULEFILES_DIR) # Make sure usr can write to $MODULEFILES_DIR/..
  test -w $DIR_ABOVE 
  if [[  $? != 0 ]]; then
     echo "  -> ERROR:  Cannot write into directory ABOVE: $MODULEFILES_DIR"
     echo "  ->         Is the intended modulesfile directory, $MODULEFILES_DIR?"
     echo "  ->         If it is, please allow write permission to $DIR_ABOVE."
     exit 9
  fi

  #                          # Internal Variables are set here
  
         NAME_cap=$( echo $NAME | tr '[:lower:]' '[:upper:]' )
         NAME_sml=$( echo $NAME | tr '[:upper:]' '[:lower:]' )
  
       MODULE_DIR=$MODULEFILES_DIR/${PREFIX_sml}$NAME_sml
 if [[ $FLAVOR == "lmod" ]]; then
           MODULE=${VER}.lua
 else
           MODULE=${VER}
fi
  
           BASHRC=$HOME/.bashrc
  
  #                          # Preparations here

  #   IF MODULE_DIR is accessible (mkdir -p)  -- exit otherwise
  
       mkdir -p $MODULE_DIR    #no-op if already exists and writable
       if [[ ! $? ]]; then
          echo "  -> ERROR: Could not use \$MODULE_DIR: $MODULE_DIR"
          echo "  ->        Please correct and rerun $0."
          exit 3
       else
          echo "  -> Able to access|create \$MODULE_DIR: $MODULE_DIR"
       fi

  #                          # Specialized Variables used in the modulefile
  #                          # Give values if not defined by user

       HELP_MESSAGE_INC=none    #default, no module_help_message to be included

       [[ -f  $HELP_FILE ]] &&  echo "  -> Including help message from $HELP_FILE file."

       if [[ "$HELP_MESSAGE"  =~ [^[:space:]]  ]]; then
          if [[ -f   $HELP_FILE ]]; then
             echo  "  -> WARNING: Found \$HELP_MESSAGE environment variabable."
             echo  "  ->          AND $HELP_FILE file."
             echo  "  ->          ONLY ONE SHOULD EXIST."
             echo  "  ->          Using contents of file for help message."
          else
             echo "  -> Will include help message from \$HELP_MESSAGE environment variable." 
          fi
          HELP_MESSAGE_INC=message
       fi

  #                          # If AUTO_HELP is spaces or not defined, help messages are automatically
  #                          # created for distro_dirs, PATH variables insertion, environment variables
  #                          # module usage (including prerequisites, and version, respectively:
  #                          # ( dirs paths envs module version )
  #                          
       if [[ ! $AUTO_HELP =~ [^[:space:]] ]]; then
                             # Include all automatic help messages
          AUTO_HELP_INC=( dirs paths envs module version )
       else
                             # if value is "none" then make AUTO_HELPER empty
          if [[ $AUTO_HELP =~ none ]]; then
             AUTO_HELP_INC=""
          else
                             # If not "none", then AUTO_HELP must have a list of automatic
                             # message names (from this list: dirs paths envs module version ).
                             # From this list make an array in AUTO_HELP_INC.
             IFS=' ' read -r -a AUTO_HELP_INC <<< "$AUTO_HELP"
          fi
       fi

       if [[ ! "$FAMILY"        =~ [^[:space:]]  ]]; then
          FAMILY=$NAME_sml
       else
          [[ $FAMILY == none ]] && FAMILY=""   # exception, no family if "none"
       fi
  
  #                          # Defaults: set env VARS: <prefix><NAME>_DIR and <prefix><NAME>_BIN
  #                          # Defaults: add bin directory to PATH


  # topdir_env_list
  
       if [[ ! "$topdir_env_list"  =~ [^[:space:]] ]] ; then
         #topdir_env_default=( bin lib libs inc man doc docs )
          topdir_env_default=( bin lib libs lib64 include man doc docs share tools bench benchmark data Examples examples tutorials)

          topdir_env_list=(dir)   # This must exist!  dir mean "topdir"
          for dir in ${topdir_env_default[@]}; do
            [[ -d $TOPDIR/$dir ]] && topdir_env_list+=($dir)
          done

          echo "  -> Autocheck found these directories in \$TOPDIR: ${topdir_env_list[@]}"
          echo "  ->           Will create ${PREFIX_cap}${NAME_cap}_<DIR> environment vars for these."
       else
          topdir_env_string=$topdir_env_list
          topdir_env_list=()
          IFS=' ' read -r -a topdir_env_list <<<$topdir_env_string
       fi

 
  # topdir_path_list

       if [[ ! "$topdir_path_list" =~ [^[:space:]]  ]]; then
          if [[ -d $TOPDIR/bin ]]; then
             topdir_path_list+=(bin)
             echo "  -> Autocheck found bin in \$TOPDIR."
             echo "  ->           Will include in PATH."
          fi
          if [[ -d $TOPDIR/scripts ]]; then
             topdir_path_list+=(scripts)
             echo "  -> Autocheck found scripts in \$TOPDIR."
             echo "  ->           Will include in PATH."
          fi
       else
          topdir_path_string=$topdir_path_list 
          topdir_path_list=()
          IFS=' ' read -r -a topdir_path_list <<<$topdir_path_string
       fi

  # topdir_ldpath_list

       if [[ ! "$topdir_ldpath_list" =~ [^[:space:]]  ]]; then
          [[ -d $TOPDIR/lib   ]] && topdir_ldpath_list=(lib)
          [[ -d $TOPDIR/libs  ]] && topdir_ldpath_list=(libs)
          [[ -d $TOPDIR/lib64 ]] && topdir_ldpath_list=(lib64)
          if [[ ${#topdir_ldpath_list[@]} > 0 ]] ;then
             echo "  -> Autocheck found ${topdir_ldpath_list[@]} in \$TOPDIR."
             echo "  ->           Will include in LD_LIBRARY_PATH."
          fi
       else
          topdir_ldpathstring=$topdir_ldpathlist
          topdir_ldpathlist=()
          IFS=' ' read -r -a topdir_ldpathlist <<<$topdir_ldpathstring
       fi


  # topdir_manpath_list

       if [[ ! "$topdir_manpath_list" =~ [^[:space:]]  ]]; then
          if [[ -d $TOPDIR/man ]]; then
             topdir_manpath_list=(man)
             echo "  -> Autocheck found man in \$TOPDIR."
             echo "  ->           Will include in MANPATH."
          fi
       else
          topdir_manpath_string=$topdir_manpath_list
          topdir_manpath_list=()
          IFS=' ' read -r -a topdir_manpath_list <<<$topdir_manpath_string
       fi

  
  # topdir_pythonpath_list

       if [[ ! "$topdir_pythonpath_list" =~ [^[:space:]]  ]]; then
          if [[ -d $TOPDIR/python ]]; then
             topdir_pythonpath_list=(python)
             echo "  -> Autocheck found python in \$TOPDIR."
             echo "  ->           Will include in PYTHONPATH."
          fi
       else
          topdir_pythonpath_string=$topdir_pythonpath_list
          topdir_pythonpath_list=()
          IFS=' ' read -r -a topdir_pythonpath_list <<<$topdir_pythonpath_string
       fi

  
       echo "  -> Modulefile  ${MODULE_prefix}$NAME_sml/$MODULE  will go in $MODULEFILES_DIR" 


  ##beg HELP_FILE
  # HELP_FILE exits, use it instead of default or user-defined HELP_MESSAGE

  if [[ -f   $HELP_FILE ]]; then
     ORIG_HELP_FILE=$HELPFILE
     HELP_MESSAGE_INC=message
                              # Remove any empty line at beginning of file:
                              # p means print after pattern matching.
                              # $ means evaluate \t
    #sed -n $'/[^ \t]/,$p' $HELP_FILE >/tmp/module_help_file.$$
     sed -r -n '/[^ \t]/,$p' $HELP_FILE >/tmp/module_help_file.$$

     HELP_FILE=/tmp/module_help_file.$$

     #https://stackoverflow.com/questions/19767593/sed-command-to-delete-empty-lines-till-the-first-occurrence-of-sentence
     #https://www.gnu.org/software/sed/manual/sed.html#Multiline-techniques

     echo "  -> Found the helpfile $ORIG_HELP_FILE: WILL USE THIS for the module help message."

                  # help file contains lines that need ENV VARS for evaluation.
                  # If the file begins with specific HERE FILE syntax, then it is sources.
                  # The latter is for those making RPMs, and want the file to be of his form.

     grep -Po '\s*read.*HELP_MESSAGE.*<<[\s-]*EOF' $HELP_FILE 2>&1 >/dev/null
     if [[ ! $? == 0 ]]; then
                  # just a bunch of normal text lines . Read file
                  # Then evaluate the environment variable expressions
        help_message=$( <$HELP_FILE ) 
        HELP_MESSAGE=$( eval echo \""$help_message"\" )

     else

        help_message=$( <$HELP_FILE ) 
        source $HELP_FILE
        echo "  -> Determined that $HELP_FILE has HERE FILE syntax-- will source it."
     fi
                  # Report any variables that have no values
                  # (sed is for removing "\$..." from consideration)
                  # Capture in arrays vars of the form $... (normal) and ${...} squiggle
     normal_vars=(   $(cat $HELP_FILE | sed 's/\\\$//' | grep -Po '\$\K[a-z,A-Z,0-9,_]*') )
     squiggle_vars=( $(cat $HELP_FILE | sed 's/\\\$//' | grep -Po '\${\K[^}]*') )
   
                     # Now Check to see if the variables are in the environment
                     # Do not report variables which are not just space.
                     # Sorry, it is a lot easier to program the double negative here.
     for normal_var in "${normal_vars[@]}"; do
       env_val=$( eval echo \"\$$normal_var\" )
       if [[ ! $env_val =~ [^[:space:]] ]]; then
         echo "  -> WARNING: Environment Variable $normal_var is not defined (found \$$normal_var format) ."
       fi
     done
   
     for squiggle_var in "${squiggle_vars[@]}"; do
       env_val=$( eval echo \"\$$squiggle_var\" )
       if [[ ! $env_val =~ [^[:space:]] ]]; then
         echo "  -> WARNING: Environment Variable $normal_var is not defined (has \${$squiggle_var} format)."
       fi
     done
   
  fi

  ##end HELP_FILE

         
 ##END--^  Modulefile Prep
  
  module=()
                 #Will include help_message string here later 
                 #This helps with debugging when message is long.

 if [[ $FLAVOR == "lmod" ]]; then
     module+=( "help(help_msg,\"\\n\")" )
     module+=( "$l_divider" )
 fi


  if [[ "$WHATIS" =~ [^[:space:]]  ]]; then
     echo "  -> Including \"whatis\" information in the modulefile."

     IFS='@' read -r -a lines <<< $WHATIS

     for text in "${lines[@]}"; do
                         #trim text
        shopt -s extglob
        a="${text##*( )}"; trimmed_text="${a%%*( )}"
        shopt -u extglob
       if [[ $FLAVOR == "lmod" ]]; then
        module+=( "whatis(\"$trimmed_text\")" )
       else
        module+=( "module-whatis \"$trimmed_text\"" )
       fi # flavor

     done
  fi

                # Version 1 now uses numbered variables (WHATIS1, WHATIS2,...)
  if [[  "$WHATIS1"  =~ [^[:space:]] ]]; then  #only do if WHATISx exist
     for i in `seq 1 30`; do
       text=$( eval echo \"\$WHATIS$i\" )
       if [[  "$text"  =~ [^[:space:]] ]]; then
         shopt -s extglob
         a="${text##*( )}"; trimmed_text="${a%%*( )}"
         shopt -u extglob

        if [[ $FLAVOR == "lmod" ]]; then
         module+=( "whatis(\"$trimmed_text\")" )
        else
         module+=( "module-whatis \"$trimmed_text\"" )
        fi
       fi
     done
  fi
               # Just add any whatis information in default modules_whatis file
               # or a user-specified file ($WHATIS_FILE)

  default_file=$TOPDIR/modules_whatis; default_exists=false
  [[ -e $default_file  ]] &&  [[ -r $default_file ]] && default_exists=true

  if [[ ! $WHATIS_FILE =~ [^[:space:]] ]]; then
    if [[ -e $default_file  ]] &&  [[ -r $default_file ]]; then
       WHATIS_FILE=$default_file
       echo "  -> Including whatis info from (app) $default_file file."
    fi
  else
    if [[ $default_exists == true ]]; then
       echo "  -> WARNING:  You designated a whatis file as $WHATIS_FILE."
       echo "  ->           This will override the use of the default whatis file"
       echo "  ->           at $default_file, for the application."
       echo "  ->           You might want to unset WHATIS_FILE and use the default."
       echo "  ->           This is probably what you want to do. --"
       echo "  ->           OR to include both sets of information, unset WHATIS_FILE"
       echo "  ->              and set WHATIS env vars with the information in $WHATIS_FILE."
       echo "  ->              See mkmod --help for more WHATIS env var info."
    fi
  fi

  if [[ $WHATIS_FILE =~ [^[:space:]] ]] && [[ -e $WHATIS_FILE  ]] &&  [[ -r $WHATIS_FILE ]]; then
    while IFS= read -r text; do
       shopt -s extglob
       a="${text##*( )}"; trimmed_text="${a%%*( )}"
       shopt -u extglob
       if [[ $FLAVOR == "lmod" ]]; then
          module+=( "whatis(\"$trimmed_text\")" )
       else
          module+=( "module-whatis \"$trimmed_text\"" )
       fi
    done < $WHATIS_FILE
    if [[ $default_exists == false ]]; then
       echo "  -> Including whatis information from $WHATIS_FILE file."
    fi
  fi



  [[ $FLAVOR == "lmod" ]] && module+=( "$l_divider" )
  [[ $FLAVOR == "tmod" ]] && module+=( "$t_divider" )
  
  if [[ $FLAVOR == "lmod" ]] ; then
     [[ "$FAMILY" =~ [^[:space:]]  ]]&&  module+=( "family(\"$FAMILY\")" )
  fi

##########BEG--v PREREQs

 if [[ ! "$AUTO_PREREQ" =~ none  ]]; then

  ## Compiler prereq
  comp_mpi_prereq=()

  if [[ $FLAVOR == "lmod" ]]; then

   if [[ ! "$COMPILER_PREREQ" =~ [^[:space:]]  ]]; then
     if [[ "$LMOD_FAMILY_COMPILER_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_COMPILER" =~ [^[:space:]] ]]; then
       COMPILER_PREREQ=$LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION
       echo "  -> Setting COMPILER PREREQ to $LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION"
       comp_mpi_prereq=( "$COMPILER_PREREQ" )
      #module+=( "prereq(\"$COMPILER_PREREQ\")" )
     fi
   else  # COMPILER_PREREQ set
     if [[ "$LMOD_FAMILY_COMPILER_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_COMPILER" =~ [^[:space:]] ]]; then
         if [[ $LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION != $COMPILER_PREREQ ]]; then
           echo ""
           echo "  -> WARNING:"
           echo "  ->         COMPILER PREREQ=$COMPILER_PREREQ"
           echo "  ->   BUT   LMOD_FAMILY_COMPILER/LMOD_FAMILY_COMPILER_VERSION=$LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION"
           echo ""
         fi
     fi
    #module+=( "prereq(\"$COMPILER_PREREQ\")" )
    comp_mpi_prereq="$COMPILER_PREREQ"
   fi
 
 
   ## MPI prereq
   if [[ ! "$MPI_PREREQ" =~ [^[:space:]]  ]]; then
 
     if [[ "$LMOD_FAMILY_MPI_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_MPI" =~ [^[:space:]] ]]; then
       MPI_PREREQ=$LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION
       echo "  -> Setting MPI PREREQ to $LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION"
       comp_mpi_prereq+=( "$MPI_PREREQ" )
       #module+=( "prereq(\"$MPI_PREREQ\")" )
     fi
 
   else  # MPI_PREREQ set
 
     if [[ "$LMOD_FAMILY_MPI_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_MPI" =~ [^[:space:]] ]]; then
         if [[ $LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION != $MPI_PREREQ ]]; then
           echo "" 
           echo "  -> WARNING:"
           echo "  ->         MPI PREREQ=$MPI_PREREQ"
           echo "  ->   BUT   LMOD_FAMILY_MPI/LMOD_FAMILY_MPI_VERSION=$LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION"
           echo ""
         fi
     fi
     comp_mpi_prereq+=( "$MPI_PREREQ" )
     #module+=( "prereq(\"$MPI_PREREQ\")" )
   fi

   if [[ "$comp_mpi_prereq" =~ [^[:space:]]  ]]; then
     list=""; comma=""
     for prereq in "${comp_mpi_prereq[@]}"; do
       list="${list}${comma} \"$prereq\""
       comma=","
     done
 
     module+=( "prereq($list)" )
 
   fi

  else # ^--lmod  v--tmod

   ######BEG--^ tmod   COMPILER
   #COMPILER
                          #Find the loaded compilers
   loaded_compilers=()
   comp_count=0
   IFS=':' read -r -a loaded_compilers <<< "$LOADEDMODULES"
   for loaded_compiler in  "${loaded_compilers[@]}"; do
      for compiler in  "${compilers[@]}"; do
        #if [[ $loaded_compiler =~ "$compiler/" ]]; then
         if [[ ${loaded_compiler%%/*} =~ "$compiler" ]]; then
            comp_count=$(( comp_count + 1 ))
            [[ $MKMOD_DEBUG =~ [^[:space:]] ]] &&  
               echo "Found compiler=$compiler  loaded_compiler=$loaded_compiler"
         fi
      done

   done


   if [[ ! "$COMPILER_PREREQ" =~ [^[:space:]]  ]]; then

      if (( $comp_count > 1 )); then
         echo "  -> ERROR:  Houston, we have a problem."
         echo "  ->         Found two compilers loaded at the same time:"
         echo "  ->         ${loaded_compilers[@]}"
         echo "  ->         If you need this export \$COMPILER_PREREQ with:"
         echo "  ->         ${loaded_compilers[@]}"
         exit
      fi

      if (( $comp_count == 1 )); then
         module+=( "prereq ${loaded_compilers[0]}" )
      fi


   else  # COMPILER_PREREQ set

                          #COMPILER_PREREQ must be a specific compiler
                          #allow corner case of multiple compilers for COMPILER_PREREQ
    matches=0
    IFS=' ' read -r -a prereq_compilers <<< "$COMPILER_PREREQ"
#                              echo "prereq_compilers=${prereq_compilers[@]}"

                          # Check for matching loaded compiler(s) 
    for prereq_compiler in "${prereq_compilers[@]}"; do
      for loaded_compiler in  "${loaded_compilers[@]}"; do
         if [[ $prereq_compiler == "$loaded_compiler" ]]; then
            matches=$(( matches + 1 ))
         fi
      done
    done
 
                          # disparity between what is loaded and prereq-requested, then point this out.
    if (( ${#loaded_compilers[@]} != ${#prereq_compilers[@]} || ${#prereq_compilers[@]} != $matches )); then
                          #User specified Compiler PREREQ didn't match loaded compilers
                          #Make sure user knows about this JIC.
       echo "  -> FYI:" 
       echo "  ->      PREREQ           compilers: ${prereq_compiler[@]} "
       echo "  ->      Presently loaded compilers: ${loaded_compilers[@]} "
       echo ""
    fi

    echo "  -> Including Compiler Prerequite:  ${prereq_compiler[@]} "
    for prereq_compiler in "${prereq_compilers[@]}"; do
       module+=( "prereq $prereq_compiler" )
    done

   fi #end NO-COMPILER_PREQ  COMPILER_PREQ

   ######END--^ tmod   COMPILER

   #MPI
   ######BEG--v tmod   MPI
                           #Find the loaded MPIs
   loaded_MPIs=()
   MPI_count=0
   IFS=':' read -r -a loaded_MPIs <<< "$LOADEDMODULES"
   for loaded_MPI in  "${loaded_MPIs[@]}"; do

      for MPI in  "${MPIs[@]}"; do
         if [[ ${loaded_MPI%%/*} =~ "$MPI" ]]; then
            MPI_count=$(( MPI_count + 1 ))
            [[ $MKMOD_DEBUG =~ [^[:space:]] ]] &&  
               echo "Found MPI=$MPI  loaded_MPI=$loaded_MPI"
         fi
      done

   done
                         #MPI_PREREQ must be a specific MPI
                         #Only 1 is ever allowed
   if (( $MPI_count > 1 )); then
      echo "  -> ERROR:  Houston, we have a problem."
      echo "  ->         Found two or more MPIs loaded at the same time:"
      echo "  ->         ${loaded_MPIs[@]}"
      echo "  ->         To circumvent this set \$MPI_PREREQ"
      exit
   fi



   if [[ ! "$MPI_PREREQ" =~ [^[:space:]]  ]]; then 

      module+=( "prereq ${loaded_MPIs[0]}" )

   else  # MPI_PREREQ set

      matches=0           # Check for matching loaded MPI(s) 
      for loaded_MPI in  "${loaded_MPIs[@]}"; do
         if [[ "$MPI_PREREQ" == "$loaded_MPI" ]]; then
            matches=$(( matches + 1 ))
         fi
      done
                          #User specified MPI PREREQ must match loaded MPIs
                          #If note, make sure user knows about this JIC.
    if (( $matches == 0 )); then
       echo "  -> FYI:"
       echo "  ->      PREREQ           MPI: $PREREQ_MPI "
       echo "  ->      Presently loaded MPI: ${loaded_MPIs[@]} "
       echo ""
    fi

    echo "  -> Including MPI Prerequite:  $PREREQ_MPI "
    module+=( "prereq $PREREQ_MPI" )
    ######END--^ tmod   MPI

   fi   #end if else MPI NOPREREQ | PREREQ


###########################################################

  fi   #end if else lmod | tmod

 fi   #end if not AUTO_PREREQ=none

               #Now add explict PREREQS

 if [[ $PREREQ =~ [^[:space:]] ]]; then
   IFS=' ' read -r -a prereqs <<< "$PREREQ"
   for prereq in  "${prereqs[@]}"; do
     if [[ $FLAVOR == "lmod" ]]; then
       module+=("prereq( \"$prereq\" )" ) 
     else
       module+=("prereq $prereq" ) 
     fi
   done
 fi


##########ENV--^ PREREQs

 ## TOPDIR (as a local variable)
if [[ $FLAVOR == "lmod" ]]; then
  module+=( "$l_divider" )
  module+=("     local topdir   = \"$TOPDIR\"")
  module+=( "$l_divider" )
else
  module+=( "$t_divider" )
  module+=(  "     set topdir     \"$TOPDIR\"")
  module+=( "$t_divider" )
fi

  
 ## DEFAULT package variable (e.g. of form MY_PKGNAME_DIR=<directory> )

  at=""; bs=""
 #[[ $FLAVOR == "tmod" ]] && bs="\\"
  [[ $FLAVOR == "tmod" ]] && bs=""

  for dir in ${topdir_env_list[@]}; do
     DIR=$( echo $(basename $dir) | tr '[:lower:]' '[:upper:]' )
     #TACC Convention (no S)
     [[ $DIR == "DOCS"     ]] && DIR=DOC; [[ $DIR == "SHARE"      ]] && DIR=SHR
     [[ $DIR == "BENCH"    ]] && DIR=BEN; [[ $DIR == "BENCHMARK"  ]] && DIR=BEN
     [[ $DIR == "TOOLS"    ]] && DIR=TOL; 
     [[ $DIR == "INCLUDE"  ]] && DIR=INC; 
     [[ $DIR == "DATA"     ]] && DIR=DAT; 
     [[ $DIR == "LIBS"     ]] && DIR=LIB; [[ $DIR == "LIB64"      ]] && DIR=LIB
     [[ $DIR == "EXAMPLES" ]] && DIR=EXM; [[ $DIR == "TUTORIALS"  ]] && DIR=TUT

     if [[ $dir =~ dir   ]]; then
       if [[ $FLAVOR == "lmod" ]]; then
        module+=( "setenv(\"${PREFIX_cap}${NAME_cap}_${DIR}\", topdir)" )
       else
        module+=( "setenv   ${PREFIX_cap}${NAME_cap}_${DIR}  \$topdir"  )
       fi
        DISTRO_DIRS+=" $at $bs\$${PREFIX_cap}${NAME_cap}_${DIR}      $TOPDIR";      at="@"
     else
       if [[ $FLAVOR == "lmod" ]]; then
        module+=( "setenv(\"${PREFIX_cap}${NAME_cap}_${DIR}\", pathJoin(topdir,\"$dir\"))" )
       else
        module+=( "setenv   ${PREFIX_cap}${NAME_cap}_${DIR}           \$topdir/$dir" )
       fi
        DISTRO_DIRS+=" $at $bs\$${PREFIX_cap}${NAME_cap}_${DIR}      $TOPDIR/$dir"; at="@"
     fi

  done


 ## DEFAULT path environment variables (path relative to $TOPDIR)

    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "$l_divider" )
    else
     module+=( "$t_divider" )
    fi
  
                             # If no topdir bin directory exist, put topdir in PATH
                                                          at=""
  if [[ ! "$topdir_path_list" =~ [^[:space:]]  ]]; then  
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"PATH\", topdir)" )
    else
     module+=( "prepend-path   PATH  \$topdir" )
    fi
     module+=( " " )

     PATH_DIRS+=" $at $bs\$PATH              $TOPDIR" ;      at="@"
                       #123456789012345...^
  fi
  
  for dir in ${topdir_path_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"PATH\", pathJoin(topdir,\"$dir\"))" )
    else
     module+=( "prepend-path   PATH           \$topdir/$dir" )
    fi

     PATH_DIRS+=" $at $bs\$PATH              $TOPDIR/$dir" ; at="@"
                       #123456789012345...^
  done
  
  for dir in ${topdir_ldpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"LD_LIBRARY_PATH\", pathJoin(topdir,\"$dir\"))" )
    else
     module+=( "prepend-path   LD_LIBRARY_PATH           \$topdir/$dir" )
    fi

     PATH_DIRS+=" $at $bs\$LD_LIBRARY_PATH   $TOPDIR/$dir" ; at="@"
                       #123456789012345...^
  done
  
  for dir in ${topdir_manpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"MANPATH\", pathJoin(topdir,\"$dir\"))" )
    else
     module+=( "prepend-path   MANPATH           \$topdir/$dir" )
    fi

     PATH_DIRS+=" $at $bs\$MANPATH           $TOPDIR/$dir" ; at="@"
                       #123456789012345...^
  done

  for dir in ${topdir_pythonpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"PYTHONPATH\", pathJoin(topdir,\"$dir\"))" )
    else
     module+=( "prepend-path   PYTHONPATH           \$topdir/$dir" )
    fi

     PATH_DIRS+=" $at $bs\$PYTHONPATH        $TOPDIR/$dir" ; at="@"
                       #123456789012345...^
  done

     module+=( " " )
  
  
 ## USER-DEFINED path environment variables (full path)

  for dir in ${path_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"PATH\",\"$dir\")" )
    else
     module+=( "prepend-path   PATH     $dir" )
    fi

     PATH_DIRS+=" $at $bs\$PATH              $dir" ; at="@"
                       #123456789012345...^
  done
  
  for dir in ${ldpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"LD_LIBRARY_PATH\",\"$dir\")" )
    else
     module+=( "prepend-path   LD_LIBRARY_PATH     $dir" )
    fi

     PATH_DIRS+=" $at $bs\$LD_LIBRARY_PATH   $dir" ; at="@"
                       #123456789012345...^
  done
  for dir in ${manpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"MANPATH\",\"$dir\")" )
    else
     module+=( "prepend-path   MANPATH     $dir" )
    fi

     PATH_DIRS+=" $at $bs\$MANPATH           $dir" ; at="@"
                       #123456789012345...^
  done
  for dir in ${pythonpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"PYTHONPATH\",\"$dir\")" )
    else
     module+=( "prepend-path   PYTHONPATH     $dir" )
    fi

     PATH_DIRS+=" $at $bs\$PYTHONPATH        $dir" ; at="@"
                       #123456789012345...^
  done
  
  
  if [[ "$MKMOD_DEBUG"  =~ [^[:space:]]  ]]; then
       FILE=/tmp/${USER}_${MODULE}_$$
  else
       FILE=$MODULE_DIR/$MODULE
  fi

  ##vvv begin Gather all help messages together

  if [[ $AUTO_HELP_INC =~ module ]]; then

     HELP_MODULE=$'\n   '"USAGE -- MODULES"
     HELP_MODULE+=$'\n   '
    if [[ $FLAVOR == "lmod" ]]; then
     HELP_MODULE+=$'\n   '" Required Modules"
     HELP_MODULE+=$'\n   '" module load $COMPILER_PREREQ $MPI_PREREQ       (required if not system defaults)"
    fi
     HELP_MODULE+=$'\n   '
     HELP_MODULE+=$'\n   '" Application Modules"
     HELP_MODULE+=$'\n   '
     HELP_MODULE+=$'\n   '" module load $MODULE"

  fi

  if [[ ${AUTO_HELP_INC[@]} =~ dirs ]]; then
     HELP_DIRS=""
     HELP_DIRS+=$'\n   ENV VAR - INFO'
     HELP_DIRS+=$'\n    '"\$${PREFIX_cap}${NAME_cap}_VER      $VER"
     HELP_DIRS+=$'\n    '"\$${PREFIX_cap}${NAME_cap}_MOD      $MODULE_DIR/$MODULE"


     HELP_DIRS+=$'\n'
     HELP_DIRS+=$'\n   ENV VAR - DISTRO        (SUB)DIRECTORY'

     IFS='@' read -r -a text <<< "$DISTRO_DIRS"
     for text in "${text[@]}"; do
                         #trim text
        shopt -s extglob
        a="${text##*( )}"; trimmed_text="${a%%*( )}"
        shopt -u extglob
        HELP_DIRS+=$'\n    '"$trimmed_text"

     done
     HELP_DIRS+=$'\n'

  fi


  if [[ ${AUTO_HELP_INC[@]} =~ paths ]]; then
     HELP_PATHS=""
     HELP_PATHS+=$'\n   ENV PATH VAR                 DIRECTORY ADDED'

     IFS='@' read -r -a text <<< "$PATH_DIRS"
     for text in "${text[@]}"; do
                         #trim text
        shopt -s extglob
        a="${text##*( )}"; trimmed_text="${a%%*( )}"
        shopt -u extglob
        HELP_PATHS+=$'\n    '"$trimmed_text"

     done
     HELP_PATHS+=$'\n'

  fi

                    # Include user-defined environment variables
  if [[ ${AUTO_HELP_INC[@]} =~ envs ]]; then
     if [[  "$ENV1"  =~ [^[:space:]] ]]; then  #only do if ENVx exist
        HELP_ENVS=$'\n   ENV VAR - SUPPORT' 
        for i in `seq 1 30`; do
          env=$( eval echo \"\$ENV$i\" )
          if [[  "$env"  =~ [^[:space:]] ]]; then
            IFS='= ' read -r key val <<< "$env"
            line=$(printf "%20s = %s" "$key" "$val")
            HELP_ENVS+=$'\n'"$line"
          fi
        done
        HELP_ENVS+=$'\n'
     fi
  fi


  if [[ ${AUTO_HELP_INC[@]} =~ version ]]; then
     HELP_VERSION=$'\n\n'"   $NAME_sml Version: $VER"$'\n'
  fi
 
 
  if [[ "$MKMOD_DEBUG" =~ [^[:space:]] ]]; then
     echo "  ->> MKMOD_DEBUG: These AUTOMATIC HELP MESSAGES were selected to include in the modulefile:"
     echo "  ->>              ${AUTO_HELP_INC[@]}"
    #echo "$HELP_DIRS" "$HELP_PATHS" "$HELP_ENVS" "$HELP_MODULE" "$HELP_MESSAGE" "$HELP_VERSION" 
  fi

  ##^^^ end   Gather all help messages together



  echo "  -> Creating $MODULE.  Full path = $MODULE_DIR/$MODULE"

 ## vvv NOW (finally) INSERT  appropriate content into the module file ($FILE)

  rm -f $FILE; touch $FILE
                    # Include help message
  if [[ $FLAVOR == "lmod" ]]; then
   echo "-------------------------------------------------------"     >> $FILE
   echo "-- generated by mkmod $MKMOD_VERSION   user: $USER --"       >> $FILE
   echo "-------------------------------------------------------"     >> $FILE
  else
   echo "#%Module1.0"                                                 >> $FILE
   echo "#######################################################"     >> $FILE
   echo "## generated by mkmod $MKMOD_VERSION   user: $USER ##"       >> $FILE
   echo "#######################################################"     >> $FILE
  fi

  echo ""                                                             >> $FILE

 if [[ $FLAVOR == "lmod" ]]; then
  echo "local help_msg = [[ "                                          >> $FILE
 else
  echo "proc ModulesHelp { } { "                                       >> $FILE
  echo "puts { "                                                       >> $FILE
 fi
  [[ ${AUTO_HELP_INC[@]}     =~ dirs        ]] && echo "$HELP_DIRS"    >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ paths       ]] && echo "$HELP_PATHS"   >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ envs        ]] && echo "$HELP_ENVS"    >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ module      ]] && echo "$HELP_MODULE"  >> $FILE
  [[       $HELP_MESSAGE_INC =~ message     ]] && echo "$HELP_MESSAGE" >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ version     ]] && echo "$HELP_VERSION" >> $FILE
 if [[ $FLAVOR == "lmod" ]]; then
  echo "]] "                                                           >> $FILE
 else
  echo "  }"                                                           >> $FILE
  echo "} "                                                            >> $FILE
 fi
  echo ""                                                              >> $FILE

  
                    # Include module array content
  for i in "${module[@]}"; do
     echo $i             >> $FILE
  done
  echo ""                >> $FILE
  
    #if [[ "$ENV_KEY" =~ [^[:space:]]  ]]; then
    #   env_key=($ENV_KEY)
    #   env_val=($ENV_VAL)
    #   for i in `seq 0 $((${#env_key[@]}-1))`; do
    #      echo "setenv( \"${env_key[$i]}\",  \"${env_val[$i]}\" )" >> $FILE
    #   done
    #fi
  
                    # Include user-defined environment variables
    for i in `seq 1 30`; do
      env=$( eval echo \"\$ENV$i\" )
      if [[  "$env"  =~ [^[:space:]] ]]; then
         IFS='= ' read -r key val <<< "$env"
                         if [[ $FAVOR == "lmod" ]]; then
                          echo "setenv( \"${key}\",  \"${val}\" )" >> $FILE
                         else
                          echo "setenv ${key} ${val}"              >> $FILE
                         fi
         HELP_ENV_KEY+=(${key})
         HELP_ENV_VAL+=(${val})
      fi
    done

  echo ""                >> $FILE
  
                    # Include user-defined (custom) LUA commands
    for i in `seq 1 30`; do
      cmd=$( eval echo \"\$CMD$i\" )
      [[  "$cmd"  =~ [^[:space:]] ]] &&          echo "$cmd" >> $FILE
    done

  echo ""                >> $FILE
  
  
    if [[ ! "$MKMOD_DEBUG"  =~ [^[:space:]]  ]]; then
       echo "  -> Finished creating and installing the modulefile for $NAME_cap."
       echo ""
    else
       echo "  ->> MKMOD_DEBUG: Printing expected modulefile without creating it."
       cat /tmp/${USER}_${MODULE}_$$
       rm  /tmp/${USER}_${MODULE}_$$
    fi

 ## ^^^ END NOW (finally) INSERT  appropriate content into the module file ($FILE)


#############END--^      CREATE MODULEFILE
  
  
#############BEG--v      GROUP ACCESS REQUEST
  
  if [[ $GROUP_ACCESS =~ [^[:space:]] ]]; then
  
     echo ""
     echo "  -> GROUP_ACCESS variable is set.  Will allow group access to modulefile."
     echo ""
   
                          # Determine which group to use
     if [[ ! $GROUP =~ [^[:space:]] ]]; then
  
                          # Use the primary group
        GROUP=`id -gn`
        group_type="primary"
        do_chgrp=no
     else
                          # User supplied Group, make sure all it is valid
        touch /tmp/imod_test.$$
        chgrp_out=`chgrp $GROUP /tmp/imod_test.$$ 2>&1`
        if [[ $? != 0 ]]; then
           do_chgrp=no
           echo "  -> WARNING: test for changing group to $GROUP failed."
           echo "  ->          CHANGE to $GROUP will NOT be performed."
           echo "  ->          chgrp output: $chgrp_out"
           #USUAL ERROR: chgrp: changing group of ‘/tmp/imod_test....’: Operation not permitted
        else
           echo "  -> Test for changing group to $GROUP passed."
           do_chgrp=yes
        fi
        rm -rf  /tmp/imod_test.$$
  
        do_chgrp=yes
        group_type="user-supplied (in GROUP variable)"
     fi
   
   
     getent_out=`getent group $GROUP`
     group_users=`echo $getent_out | sed 's/.*://'`
     echo "  -> Processing GROUP access for $group_type group $GROUP"
     echo "  -> Members of the group are: $group_users"
     echo ""
   
     do_chmod=yes
     if [[ $MODULEFILES_DIR =~  $STOCKYARD ]]; then
        CHANGE_DIRS=(  $STOCKYARD )
        CHANGE_DIRS+=( $WORK )
        BASE_DIR=$WORK
     elif [[ $MODULEFILES_DIR =~  $HOME ]]; then
        CHANGE_DIRS+=( $HOME )
        BASE_DIR=$HOME
     else
        echo "  -> GROUP ACCESS to a directory outside of \$HOME or \$WORK is not allowed."
        echo "  ->     Your modulefiles path is $MODULEFILES_DIR"
        echo "  ->     Group permissions will not be changed to provide group access."
        do_chmod=no
     fi
  
     if [[ $do_chmod == yes ]]; then
        RELATIVE_PATH=`echo $MODULEFILES_DIR | sed 's@'$BASE_DIR'/@@'`
        
        IFS='/' read -r -a dirs <<< "$RELATIVE_PATH"
     
        DIR=$BASE_DIR
        for dir in ${dirs[@]}; do
            DIR=$DIR/$dir
            CHANGE_DIRS+=( $DIR )
        done
     
        CHANGE_DIRS+=( $MODULEFILES_DIR/$MODULE_DIR )
        CHANGE_DIRS+=( $MODULEFILES_DIR/$MODULE_DIR/$MODULE )
  
                         #Now process all directories in the array.
        if [[ $do_chgrp == yes ]]; then
            echo "  -> chmod g+rX  and chgrp $GROUP  executed on: "
        else
            echo "  -> chmod g+rX  executed on: "
        fi
        for change_dir in ${CHANGE_DIRS[@]}; do
          echo "  ->    $change_dir"
         $CMD chmod g+rX $change_dir
          if [[ $do_chgrp == yes ]]; then
             $CMD chgrp $GROUP $change_dir
          fi
        done
  
     fi
     echo ""
  fi
#############END--^      GROUP ACCESS REQUEST


#############BEG--v      MODULEFILES  ACCESS

if [[ ! "$MKMOD_DEBUG"  =~ [^[:space:]]  ]] && [[ ! "$USE_IN_BASHRC"  =~ none  ]] ; then
  echo "  -> MODULEFILES DIRECTORY ACCESS (USE):"
  echo "  -> Checking for \"module use $MODULEFILES_DIR\" in \$HOME/.bashrc."

   grep -e  "$MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT" $BASHRC >/dev/null

   if [[ $? == 0 ]]; then
      echo "  -> Note: \"module use $MODULEFILES_DIR\" is already in \$HOME/.bashrc."
      chx4="checking for "
   else
      chx4=""
      echo "  -> Note: Including \"module use $MODULEFILES_DIR\"  in \$HOME/.bashrc."
      echo "  -> Making backup \$HOME/.bashrc_mkmod_bu.$$."
      cp $HOME/.bashrc               $HOME/.bashrc_mkmod_bu.$$

      echo "  -> ********************************************************************"
      echo ""
      echo "  -> DON'T FORGET TO LOGOUT and LOGIN to activate "module use " in .bashrc"
      echo ""
      echo "  -> ********************************************************************"

      grep -P '^\s*export\s+__BASHRC_SOURCED__=1' $BASHRC > /dev/null

      if [[ $? == 0 ]]; then

   #                                            Insert Module Use after BASHRC_SOURCES if it exists
   #                                            include 4 spaces in front
         sed -i '/export __BASHRC_SOURCED__=1/a'"\ \ \ \ module use $MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT" $BASHRC

      else

   #                                            Otherwise, put the module use at the end
   #                                            Make sure it is only sourced (used) once at login
   #                                            and not in batch

         readarray message <<-EOF
           :
           :###############
           :# SECTION MKMOD
           :if [ -z "\$__MKMOD_BASHRC_SOURCED__" -a "$ENVIRONMENT" != BATCH ]; then
           :  export   __MKMOD_BASHRC_SOURCED__=1
           :  module use $MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT
           :fi
	EOF
        #Above EOF must have a tab before it, and nothing else (NO SPACES, just a tab)!

                            #lop off spaces up to and including ":", and print
         shopt -s extglob
         printf '%s' "${message[@]#+( ):}" >> $BASHRC
         shopt -u extglob
      fi

   fi
   echo "  -> Finished with $chx4 \"module use\" setup in \$HOME/.bashrc."
   echo ""
fi
#############END--^      MODULEFILES  ACCESS

#}

#https://stackoverflow.com/questions/6676568/how-to-print-in-a-tabular-format-in-tcl
