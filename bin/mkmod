#!/bin/bash

MKMOD_VERSION=0.9b

MKMOD_HELP=$(sed 's/^#//' <<'EOF'
#  mkmod builds & inserts a modulefile in $HOME/modulefiles.
#
#  The minimal work a user must do is export 3 variables and call mkmod.
#
#  e.g.  NAME=tau
#        VER=2.26.2p1
#        TOPDIR=$HOME/$NAME
#      
#        export NAME VER TOPDIR
#
#        mkmod
#
#  NAME   is the name of the package, less the version number.
#  VER    is the version of the package, usually found in the package name.
#  TOPDIR is the "top level directory" of the package (e.g. $HOME/tau-2.26.2p1)
#
#       Set MODULEFILE_DIR if you don't want to use $HOME/modulefiles.
#
#  
#  FEATURES - module creation
#       * Auto sets module name to my_<name>/<ver>
#       * Auto sets MY_<NAME>_<dir> Env Vars (dir=DOC/LIB/SHR/BIN/INC/DAT/EXM/TUT/TOL/DIR)
#                                            (these are called distro_dirs)
#                                            (use PREFIX=<whatever> in lieu of MY_/my_)
#       * Auto sets PATH/LD_LIB_PATH/MANPATH/PYTHONPATH
#       * Auto sets prereq (to whatever comp/mpi is loaded) and sets family
#       * Auto creates help_message: lists distro_dirs  & paths env var names & vals.
#                                    lists module command and pkg version.
#       * HELP_MESSAGE (env var)     included in help_message (e.g. loader instructions)
#       * help_message (file)        if found, includes file (does variable replacement).
#                                    (file is sourced if "here file" syntax observed)
#       * AUTO_HELP    (env var)     set to "none" or list one or more of set:
#                                    (dirs, paths, envs, module, version).
#  
#  FEATURES - module setup
#       * Sets up $HOME/modulefiles directory (mkdir, perms, etc.)
#       * Sets up "module use $HOME/modulefiles" in $HOME/.bashrc
#  
#  FEATURES - control and instrumentation
#       Defaults can be changed by these Environment Variables
#  
#       1.) MODULEFILES_DIR          (default= $HOME/modulefiles )
#       2.) GROUP_ACCESS             (if set, allow primary group access)
#       3.) GROUP                    (required for non-primary group)
#
#       4.) COMPILER_PREREQ          (default= loaded compiler)
#       5.)      MPI_PREREQ          (default= loaded MPI)
#       6.) PREREQ                   (set to "none" avoid setting compiler/mpi prereqs.)
#
#       7.) PREFIX                   (default= MY_|my_)
#       8.) FAMILY                   (default= NAME, set to "" for no family)
#       9.) HELP_FILE                (default= ./module_help_message, use when
#                                              location is now PWD.)
#      10.) USE_BASHRC               (if "none", no .bashrc check-- e.g. for RPMS)
#      11.) MKMOD_DEBUG              (if set, modulefile goes to std out)
#
#  
#       PATHS -- RELATIVE to TOPDIR
#  
#           topdir_path_list         (e.g. ="x86_64/bin")
#           topdir_ldpath_list       (e.g. ="x86_64/libraries/linpack")
#           topdir_manpath_list      (e.g. ="man linpack/man otherpkg/man")
#           topdir_pythonpath_list   (e.g. ="share/pkgs/python")
#  
#       PATHS -- FULL
#  
#           path_list                (e.g. path_list="/sbin /home1/1234/charles/bin")
#           ldpath_list              (e.g. ldpath_list="/opt/apps/papi/5.6.0/lib")
#  
#       WHATIS   (not automatic)
#  
#           WHATIS                   (@-separated list. e.g.
#                                     WHATIS="Name: PETSc @ Version: 3.8 @ Category: lib")
#  
#      ENVIROMENT -- VARIABLES       (also displayed in the help message)
#  
#          ENV1="<val1>"             (e.g. ENV1="TAU=$TOPDIR/x86_64/bin")
#          ENV2="<val2>"             (e.g. ENV2="GET_TIME_OF_DAY:PAPI_TOT_CYC:PAPI_L2_LDM")
#          ENV3="<val3>"
#  
#      COMMANDS -- LUA statements
#  
#          CMD1="<cmd1>"             (e.g. CMD1="conflict(\"boost\",\"boost-mpi\")"
#          CMD2="<cmd2>"             (e.g. CMD2="load(\"hdf5\")"#  
#  
#  COMPONENTS - order
#    1.) Help Message (see default, or contents of help_message file)
#    2.) whatis       (none by default, use WHATIS env var)
#    3.) family       (default $NAME_sml, use FAMILY env var)
#    4.) prereq's     (default=loaded Compiler/MPI, use COMPILER_PREREQ|MPI_PREREQ)
#    5.) local topdir (definition for $TOPDIR)
#    6.) prepends     (from topdir_path|ldpath|manpath|pythonpath_list) 
#    7.) prepends     (from full path path|ldpath|manpath|pythonpath_list) 
#    8.) setenv       (from ENV1, ENV2, ..., ENV30 )
#    9.) LUA cmds     (from CUSTOM1, CUSTOM2, ..., CUSTOM30)
#
#  TUTORIAL - module (LMOD)  details
#     tinyurl.com/chpc-2017-tools  (download CHPC_2017_lmod_28.pdf)
#
#                                                 author:  Kent Milfeld 3/7/2018
#  ------

EOF
)

USAGE='
  USAGE: mkmod [-h|--help]

         NAME, VER and TOPDIR must be defined and exported.
  ------
'

  if [[ $1 == "-h" ]] || [[ $1 == "--help" ]]; then
     echo "$USAGE"
     echo "$MKMOD_HELP"
     exit 0
  fi

  if [[ $1 == "-v" ]] || [[ $1 == "--version" ]]; then
     echo "VERSION=$MKMOD_VERSION"
     exit 0
  fi


  if [[ ! "$NAME"    =~ [^[:space:]]  ]] ||
     [[ ! "$VER"     =~ [^[:space:]]  ]] ||
     [[ ! "$TOPDIR"  =~ [^[:space:]]  ]] ;  then

     echo " $USAGE "
     exit 1 
  fi

                            # default help_message file is module_help_message
  [[ ! "$HELP_FILE"  =~ [^[:space:]]  ]] && HELP_FILE=module_help_message

#############BEG      CREATE MODULEFILE

 ##BEG  Modulefile Prep

  #   IF TOPDIR doesn't exist -- exit

  echo ""
  echo "  -> mkmod MODULEFILE CREATION:"
  if [[ ! -d $TOPDIR ]]; then
     echo "  -> ERROR: Could not find directory \$TOPDIR: $TOPDIR"
     echo "  ->        Application must be installed in \$TOPDIR before executing mkmod."
     exit 2
  else
     echo "  -> Found \$TOPDIR directory: $TOPDIR"
  fi

  #                          #Optional Values,  TACC Staff agree on these defaults
  
                             # Best to have a prefix so as not to confuse
                             # with production version
                             # (e.g. ml intel/18.0.0    gamess #production version)
                             # (e.g. ml intel/18.0.0 my_gamess #personal   version)
  
  #https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
                        #PREFIX NOT DEFINE, (does not include "")
  if [[ -z "${PREFIX+x}" ]]; then
     PREFIX_sml=my_
     PREFIX_cap=MY_
  else                    #USER-DEFINED PREFIX (may include "" -- which means NO prefix)
     PREFIX_cap=$( echo $PREFIX | tr '[:lower:]' '[:upper:]' )
     PREFIX_sml=$( echo $PREFIX | tr '[:upper:]' '[:lower:]' )
  fi

  echo "  -> Prefix for module is \"$PREFIX_sml\". (Set PREFIX=\"\" for none.)"

  
  if [[ ! "$MODULEFILES_DIR"  =~ [^[:space:]]  ]]; then

     MODULEFILES_DIR=$HOME/modulefiles      # Default place to put modulefiles
  fi   

  DIR_ABOVE=$(dirname $MODULEFILES_DIR) # Make sure usr can write to $MODULEFILES_DIR/..
  test -w $DIR_ABOVE 
  if [[  $? != 0 ]]; then
     echo "  -> ERROR:  Cannot write into directory ABOVE: $MODULEFILES_DIR"
     echo "  ->         Is the intended modulesfile directory, $MODULEFILES_DIR?"
     echo "  ->         If it is, please allow write permission to $DIR_ABOVE."
     exit 9
  fi

  #                          # Internal Variables are set here
  
         NAME_cap=$( echo $NAME | tr '[:lower:]' '[:upper:]' )
         NAME_sml=$( echo $NAME | tr '[:upper:]' '[:lower:]' )
  
       MODULE_DIR=$MODULEFILES_DIR/${PREFIX_sml}$NAME_sml
           MODULE=${VER}.lua
  
           BASHRC=$HOME/.bashrc
  
  #                          # Preparations here

  #   IF MODULE_DIR is accessible (mkdir -p)  -- exit otherwise
  
       mkdir -p $MODULE_DIR    #no-op if already exists and writable
       if [[ ! $? ]]; then
          echo "  -> ERROR: Could not use \$MODULE_DIR: $MODULE_DIR"
          echo "  ->        Please correct and rerun $0."
          exit 3
       else
          echo "  -> Able to access|create \$MODULE_DIR: $MODULE_DIR"
       fi

  #                          # Specialized Variables used in the modulefile
  #                          # Give values if not defined by user

       HELP_MESSAGE_INC=none    #default, no module_help_message to be included

       [[ -f  $HELP_FILE ]] &&  echo "  -> Will include help message from $HELP_FILE file."

       if [[ "$HELP_MESSAGE"  =~ [^[:space:]]  ]]; then
          if [[ -f   $HELP_FILE ]]; then
             echo  "  -> WARNING: Found \$HELP_MESSAGE environment variabable."
             echo  "  ->          AND $HELP_FILE file."
             echo  "  ->          ONLY ONE SHOULD EXIST."
             echo  "  ->          Using contents of file for help message."
          else
             echo "  -> Will include help message from \$HELP_MESSAGE environment variable." 
          fi
          HELP_MESSAGE_INC=message
       fi

  #                          # If AUTO_HELP is spaces or not defined, help messages are automatically
  #                          # created for distro_dirs, PATH variables insertion, environment variables
  #                          # module usage (including prerequisites, and version, respectively:
  #                          # ( dirs paths envs module version )
  #                          
       if [[ ! $AUTO_HELP =~ [^[:space:]] ]]; then
                             # Include all automatic help messages
          AUTO_HELP_INC=( dirs paths envs module version )
       else
                             # if value is "none" then make AUTO_HELPER empty
          if [[ $AUTO_HELP =~ none ]]; then
             AUTO_HELP_INC=""
          else
                             # If not "none", then AUTO_HELP must have a list of automatic
                             # message names (from this list: dirs paths envs module version ).
                             # From this list make an array in AUTO_HELP_INC.
             IFS=' ' read -r -a AUTO_HELP_INC <<< "$AUTO_HELP"
          fi
       fi

       [[ ! "$FAMILY"        =~ [^[:space:]]  ]] &&  FAMILY=$NAME_sml
       if [[ ! "$FAMILY"        =~ [^[:space:]]  ]]; then
          FAMILY=$NAME_sml
       else
          [[ $FAMILY == none ]] && FAMILY=""   # exception, no family if "none"
       fi
  
  #                          # Defaults: set env VARS: <prefix><NAME>_DIR and <prefix><NAME>_BIN
  #                          # Defaults: add bin directory to PATH


  # topdir_env_list
  
       if [[ ! "$topdir_env_list"  =~ [^[:space:]] ]] ; then
         #topdir_env_default=( bin lib libs inc man doc docs )
          topdir_env_default=( bin lib libs lib64 include man doc docs share tools bench benchmark data Examples examples tutorials)

          topdir_env_list=(dir)   # This must exist!  dir mean "topdir"
          for dir in ${topdir_env_default[@]}; do
            [[ -d $TOPDIR/$dir ]] && topdir_env_list+=($dir)
          done

          echo "  -> Autocheck found these directories in \$TOPDIR: ${topdir_env_list[@]}"
          echo "  ->           Will create ${PREFIX_cap}${NAME_cap}_<DIR> environment vars for these."
       fi

 
  # topdir_path_list

       if [[ ! "$topdir_path_list" =~ [^[:space:]]  ]]; then
          if [[ -d $TOPDIR/bin ]]; then
             topdir_path_list+=(bin)
             echo "  -> Autocheck found bin in \$TOPDIR."
             echo "  ->           Will include in PATH."
          fi
          if [[ -d $TOPDIR/scripts ]]; then
             topdir_path_list+=(scripts)
             echo "  -> Autocheck found scripts in \$TOPDIR."
             echo "  ->           Will include in PATH."
          fi
       fi


  # topdir_ldpath_list

       if [[ ! "$topdir_ldpath_list" =~ [^[:space:]]  ]]; then
          [[ -d $TOPDIR/lib   ]] && topdir_ldpath_list=(lib)
          [[ -d $TOPDIR/libs  ]] && topdir_ldpath_list=(libs)
          [[ -d $TOPDIR/lib64 ]] && topdir_ldpath_list=(lib64)
          if [[ ${#topdir_ldpath_list[@]} > 0 ]] ;then
             echo "  -> Autocheck found ${topdir_ldpath_list[@]} in \$TOPDIR."
             echo "  ->           Will include in LD_LIBRARY_PATH."
          fi
       fi


  # topdir_manpath_list

       if [[ ! "$topdir_manpath_list" =~ [^[:space:]]  ]]; then
          if [[ -d $TOPDIR/man ]]; then
             topdir_manpath_list=(man)
             echo "  -> Autocheck found man in \$TOPDIR."
             echo "  ->           Will include in MANPATH."
          fi
       fi

  
  # topdir_pythonpath_list

       if [[ ! "$topdir_manpath_list" =~ [^[:space:]]  ]]; then
          if [[ -d $TOPDIR/python ]]; then
             topdir_pythonpath_list=(python)
             echo "  -> Autocheck found python in \$TOPDIR."
             echo "  ->           Will include in PYTHONPATH."
          fi
       fi

  
       echo "  -> Modulefile  ${MODULE_prefix}$NAME_sml/$MODULE  will go in $MODULEFILES_DIR" 


  ##beg HELP_FILE
  # HELP_FILE exits, use it instead of default or user-defined HELP_MESSAGE

  if [[ -f   $HELP_FILE ]]; then
     HELP_MESSAGE_INC=message

     echo "  -> Found the helpfile $HELP_FILE: WILL USE THIS for the module help message."

                  # help file be a LUA string declaration and can contain ENV VARS for evaluation.
                  # If the file also contains a specific HERE FILE syntax, then it is sources.
                  # The latter is for those making RPMs, and want the file to be of his form.

     grep -Po '\s*read.*HELP_MESSAGE.*<<[\s-]*EOF' $HELP_FILE 2>&1 >/dev/null
     if [[ ! $? == 0 ]]; then
                  # normal LUA string declaration. Read file
                  # Then evaluate the environment variable expressions
        help_message=$( <$HELP_FILE ) 
        HELP_MESSAGE=$( eval echo \"\$"$help_message"\" )

     else

        help_message=$( <$HELP_FILE ) 
        source $HELP_FILE
        echo "  -> Determined that $HELP_FILE has HERE FILE syntax-- will source it."
     fi
                  # Report any variables that have no values
                  # (sed is for removing "\$..." from consideration)
                  # Capture in arrays vars of the form $... (normal) and ${...} squiggle
     normal_vars=(   $(cat $HELP_FILE | sed 's/\\\$//' | grep -Po '\$\K[a-z,A-Z,0-9,_]*') )
     squiggle_vars=( $(cat $HELP_FILE | sed 's/\\\$//' | grep -Po '\${\K[^}]*') )
   
                     # Now Check to see if the variables are in the environment
                     # Do not report variables which are not just space.
                     # Sorry, it is a lot easier to program the double negative here.
     for normal_var in "${normal_vars[@]}"; do
       env_val=$( eval echo \"\$$normal_var\" )
       if [[ ! $env_val =~ [^[:space:]] ]]; then
         echo "  -> WARNING: Environment Variable $normal_var is not defined (found \$$normal_var format) ."
       fi
     done
   
     for squiggle_var in "${squiggle_vars[@]}"; do
       env_val=$( eval echo \"\$$squiggle_var\" )
       if [[ ! $env_val =~ [^[:space:]] ]]; then
         echo "  -> WARNING: Environment Variable $normal_var is not defined (has \${$squiggle_var} format)."
       fi
     done
   
  fi

  ##end HELP_FILE

         
 ##END  Modulefile Prep
  
  module=()
                 #Will include help_message string here later 
                 #This helps with debugging when message is long.
                
  module+=( "help(help_msg,\"\\n\")" )

  if [[ "$WHATIS" =~ [^[:space:]]  ]]; then
     echo "  -> Including \"whatis\" information in the modulefile."
     module+=( "--" )

     IFS='@' read -r -a lines <<< $WHATIS

     for text in "${lines[@]}"; do
                         #trim text
        shopt -s extglob
        a="${text##*( )}"; trimmed_text="${a%%*( )}"
        shopt -u extglob

        module+=( "whatis(\"$trimmed_text\")" )

     done
  fi

  module+=( "--" )
  
  [[ "$FAMILY" =~ [^[:space:]]  ]]&&  module+=( "family(\"$FAMILY\")" )


 ## Compiler prereq
  comp_mpi_prereq=()

 if [[ ! "$PREREQ" =~ none  ]]; then
  if [[ ! "$COMPILER_PREREQ" =~ [^[:space:]]  ]]; then

    if [[ "$LMOD_FAMILY_COMPILER_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_COMPILER" =~ [^[:space:]] ]]; then
      COMPILER_PREREQ=$LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION
      echo "  -> Setting COMPILER PREREQ to $LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION"
      comp_mpi_prereq=( "$COMPILER_PREREQ" )
     #module+=( "prereq(\"$COMPILER_PREREQ\")" )
    fi

  else  # COMPILER_PREREQ set

    if [[ "$LMOD_FAMILY_COMPILER_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_COMPILER" =~ [^[:space:]] ]]; then
        if [[ $LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION != $COMPILER_PREREQ ]]; then
          echo ""
          echo "  -> WARNING:"
          echo "  ->         COMPILER PREREQ=$COMPILER_PREREQ"
          echo "  ->   BUT   LMOD_FAMILY_COMPILER/LMOD_FAMILY_COMPILER_VERSION=$LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION"
          echo ""
        fi
    fi
   #module+=( "prereq(\"$COMPILER_PREREQ\")" )
   comp_mpi_prereq="$COMPILER_PREREQ"
  fi


 ## MPI prereq
  if [[ ! "$MPI_PREREQ" =~ [^[:space:]]  ]]; then

    if [[ "$LMOD_FAMILY_MPI_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_MPI" =~ [^[:space:]] ]]; then
      MPI_PREREQ=$LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION
      echo "  -> Setting MPI PREREQ to $LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION"
      comp_mpi_prereq+=( "$MPI_PREREQ" )
      #module+=( "prereq(\"$MPI_PREREQ\")" )
    fi

  else  # MPI_PREREQ set

    if [[ "$LMOD_FAMILY_MPI_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_MPI" =~ [^[:space:]] ]]; then
        if [[ $LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION != $MPI_PREREQ ]]; then
          echo "" 
          echo "  -> WARNING:"
          echo "  ->         MPI PREREQ=$MPI_PREREQ"
          echo "  ->   BUT   LMOD_FAMILY_MPI/LMOD_FAMILY_MPI_VERSION=$LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION"
          echo ""
        fi
    fi
    comp_mpi_prereq+=( "$MPI_PREREQ" )
    #module+=( "prereq(\"$MPI_PREREQ\")" )
  fi

  if [[ "$comp_mpi_prereq" =~ [^[:space:]]  ]]; then
    list=""; comma=""
    for prereq in "${comp_mpi_prereq[@]}"; do
      list="${list}${comma} \"$prereq\""
      comma=","
    done

    module+=( "prereq($list)" )

  fi

 fi  #end PREREQ=none

 ## TOPDIR (as a local variable)

  module+=( "--" )

  module+=("     local topdir   = \"$TOPDIR\"")
  module+=( "--" )
  
 ## DEFAULT package variable (e.g. of form MY_PKGNAME_DIR=<directory> )

  at=""

  for dir in ${topdir_env_list[@]}; do
     DIR=$( echo $(basename $dir) | tr '[:lower:]' '[:upper:]' )
     #TACC Convention (no S)
     [[ $DIR == "DOCS"     ]] && DIR=DOC; [[ $DIR == "SHARE"      ]] && DIR=SHR
     [[ $DIR == "BENCH"    ]] && DIR=BEN; [[ $DIR == "BENCHMARK"  ]] && DIR=BEN
     [[ $DIR == "TOOLS"    ]] && DIR=TOL; 
     [[ $DIR == "INCLUDE"  ]] && DIR=INC; 
     [[ $DIR == "DATA"     ]] && DIR=DAT; 
     [[ $DIR == "LIBS"     ]] && DIR=LIB; [[ $DIR == "LIB64"      ]] && DIR=LIB
     [[ $DIR == "EXAMPLES" ]] && DIR=EXM; [[ $DIR == "TUTORIALS"  ]] && DIR=TUT

     if [[ $dir =~ dir   ]]; then
        module+=( "setenv(\"${PREFIX_cap}${NAME_cap}_${DIR}\", topdir)" )
        DISTRO_DIRS+=" $at \$${PREFIX_cap}${NAME_cap}_${DIR}      $TOPDIR";      at="@"
     else
        module+=( "setenv(\"${PREFIX_cap}${NAME_cap}_${DIR}\", pathJoin(topdir,\"$dir\"))" )
        DISTRO_DIRS+=" $at \$${PREFIX_cap}${NAME_cap}_${DIR}      $TOPDIR/$dir"; at="@"
     fi

  done

 ## DEFAULT path environment variables (path relative to $TOPDIR)

     module+=( "--" )
  
                             # If no topdir bin directory exist, put topdir in PATH
                                                          at=""
  if [[ ! "$topdir_path_list" =~ [^[:space:]]  ]]; then  
     module+=( "prepend_path(\"PATH\", topdir)" )
     module+=( " " )

     PATH_DIRS+=" $at \$PATH              $TOPDIR" ;      at="@"
                       #123456789012345...^
  fi
  
  for dir in ${topdir_path_list[@]}; do
     module+=( "prepend_path(\"PATH\", pathJoin(topdir,\"$dir\"))" )

     PATH_DIRS+=" $at \$PATH              $TOPDIR/$dir" ; at="@"
                       #123456789012345...^
  done
  
  for dir in ${topdir_ldpath_list[@]}; do
     module+=( "prepend_path(\"LD_LIBRARY_PATH\", pathJoin(topdir,\"$dir\"))" )

     PATH_DIRS+=" $at \$LD_LIBRARY_PATH   $TOPDIR/$dir" ; at="@"
                       #123456789012345...^
  done
  
  for dir in ${topdir_manpath_list[@]}; do
     module+=( "prepend_path(\"MANPATH\", pathJoin(topdir,\"$dir\"))" )

     PATH_DIRS+=" $at \$MANPATH           $TOPDIR/$dir" ; at="@"
                       #123456789012345...^
  done

  for dir in ${topdir_pythonpath_list[@]}; do
     module+=( "prepend_path(\"PYTHONPATH\", pathJoin(topdir,\"$dir\"))" )

     PATH_DIRS+=" $at \$PYTHONPATH        $TOPDIR/$dir" ; at="@"
                       #123456789012345...^
  done

     module+=( " " )
  
  
 ## USER-DEFINED path environment variables (full path)

  for dir in ${path_list[@]}; do
     module+=( "prepend_path(\"PATH\",\"$dir\")" )

     PATH_DIRS+=" $at \$PATH              $dir" ; at="@"
                       #123456789012345...^
  done
  
  for dir in ${ldpath_list[@]}; do
     module+=( "prepend_path(\"LD_LIBRARY_PATH\",\"$dir\")" )

     PATH_DIRS+=" $at \$LD_LIBRARY_PATH   $dir" ; at="@"
                       #123456789012345...^
  done
  for dir in ${manpath_list[@]}; do
     module+=( "prepend_path(\"MANPATH\",\"$dir\")" )

     PATH_DIRS+=" $at \$MANPATH           $dir" ; at="@"
                       #123456789012345...^
  done
  for dir in ${pythonpath_list[@]}; do
     module+=( "prepend_path(\"PYTHONPATH\",\"$dir\")" )

     PATH_DIRS+=" $at \$PYTHONPATH        $dir" ; at="@"
                       #123456789012345...^
  done
  
  
  if [[ "$MKMOD_DEBUG"  =~ [^[:space:]]  ]]; then
       FILE=/tmp/${USER}_${MODULE}_$$
  else
       FILE=$MODULE_DIR/$MODULE
  fi


  ##vvv begin Gather all help messages together

  if [[ $AUTO_HELP_INC =~ module ]]; then

     HELP_MODULE=$'\n   '"USAGE -- MODULES"
     HELP_MODULE+=$'\n   '
     HELP_MODULE+=$'\n   '" Required Modules"
     HELP_MODULE+=$'\n   '" module load $COMPILER_PREREQ $MPI_PREREQ       (required if not system defaults)"
     HELP_MODULE+=$'\n   '
     HELP_MODULE+=$'\n   '" Application Modules"
     HELP_MODULE+=$'\n   '
     HELP_MODULE+=$'\n   '" module load $MODULE"

  fi

  if [[ ${AUTO_HELP_INC[@]} =~ dirs ]]; then
     HELP_DIRS=""
    #HELP_DIRS+=$'\n   '"$NAME_cap DIRECTORY = $TOPDIR"
     HELP_DIRS+=$'\n   ENV VAR - DISTRO        (SUB)DIRECTORY'

     IFS='@' read -r -a text <<< "$DISTRO_DIRS"
     for text in "${text[@]}"; do
                         #trim text
        shopt -s extglob
        a="${text##*( )}"; trimmed_text="${a%%*( )}"
        shopt -u extglob
        HELP_DIRS+=$'\n    '"$trimmed_text"

     done
     HELP_DIRS+=$'\n'

  fi


  if [[ ${AUTO_HELP_INC[@]} =~ paths ]]; then
     HELP_PATHS=""
     HELP_PATHS+=$'\n   ENV PATH VAR                 DIRECTORY ADDED'

     IFS='@' read -r -a text <<< "$PATH_DIRS"
     for text in "${text[@]}"; do
                         #trim text
        shopt -s extglob
        a="${text##*( )}"; trimmed_text="${a%%*( )}"
        shopt -u extglob
        HELP_PATHS+=$'\n    '"$trimmed_text"

     done
     HELP_PATHS+=$'\n'

  fi

                    # Include user-defined environment variables
  if [[ ${AUTO_HELP_INC[@]} =~ envs ]]; then
     if [[  "$ENV1"  =~ [^[:space:]] ]]; then  #only do if ENVx exist
        HELP_ENVS=$'\n   ENV VAR - SUPPORT' 
        for i in `seq 1 30`; do
          env=$( eval echo \"\$ENV$i\" )
          if [[  "$env"  =~ [^[:space:]] ]]; then
            IFS='= ' read -r key val <<< "$env"
            line=$(printf "%20s = %s" "$key" "$val")
            HELP_ENVS+=$'\n'"$line"
          fi
        done
        HELP_ENVS+=$'\n'
     fi
  fi


  if [[ ${AUTO_HELP_INC[@]} =~ version ]]; then
     HELP_VERSION=$'\n\n'"   $NAME_sml Version: $VER"$'\n'
  fi
 
 
  if [[ "$MKMOD_DEBUG" =~ [^[:space:]] ]]; then
     echo "  ->> MKMOD_DEBUG: These AUTOMATIC HELP MESSAGES were selected to include in the modulefile:"
     echo "  ->>              ${AUTO_HELP_INC[@]}"
    #echo "$HELP_DIRS" "$HELP_PATHS" "$HELP_ENVS" "$HELP_MODULE" "$HELP_MESSAGE" "$HELP_VERSION" 
  fi

  ##^^^ end   Gather all help messages together



  echo "  -> Creating $MODULE.  Full path = $MODULE_DIR/$MODULE"

 ## vvv NOW (finally) INSERT  appropriate content into the module file ($FILE)

                    # Include help message
  echo ""                 > $FILE

  echo "local help_msg = [[ "                                          >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ dirs        ]] && echo "$HELP_DIRS"    >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ paths       ]] && echo "$HELP_PATHS"   >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ envs        ]] && echo "$HELP_ENVS"    >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ module      ]] && echo "$HELP_MODULE"  >> $FILE
  [[       $HELP_MESSAGE_INC =~ message     ]] && echo "$HELP_MESSAGE" >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ version     ]] && echo "$HELP_VERSION" >> $FILE
  echo "]] "                                                           >> $FILE

  
                    # Include module array content
  for i in "${module[@]}"; do
     echo $i             >> $FILE
  done
  echo ""                >> $FILE
  
    #if [[ "$ENV_KEY" =~ [^[:space:]]  ]]; then
    #   env_key=($ENV_KEY)
    #   env_val=($ENV_VAL)
    #   for i in `seq 0 $((${#env_key[@]}-1))`; do
    #      echo "setenv( \"${env_key[$i]}\",  \"${env_val[$i]}\" )" >> $FILE
    #   done
    #fi
  
                    # Include user-defined environment variables
    for i in `seq 1 30`; do
      env=$( eval echo \"\$ENV$i\" )
      if [[  "$env"  =~ [^[:space:]] ]]; then
         IFS='= ' read -r key val <<< "$env"
                          echo "setenv( \"${key}\",  \"${val}\" )" >> $FILE
         HELP_ENV_KEY+=(${key})
         HELP_ENV_VAL+=(${val})
      fi
    done
  
                    # Include user-defined (custom) LUA commands
    for i in `seq 1 30`; do
      cmd=$( eval echo \"\$CMD$i\" )
      [[  "$cmd"  =~ [^[:space:]] ]] &&          echo "$cmd" >> $FILE
    done

  echo ""                >> $FILE
  
  
    if [[ ! "$MKMOD_DEBUG"  =~ [^[:space:]]  ]]; then
       echo "  -> Finished creating and installing the modulefile for $NAME_cap."
       echo ""
    else
       echo "  ->> MKMOD_DEBUG: Printing expected modulefile without creating it."
       cat /tmp/${USER}_${MODULE}_$$
       rm  /tmp/${USER}_${MODULE}_$$
    fi

 ## ^^^ END NOW (finally) INSERT  appropriate content into the module file ($FILE)


#############END      CREATE MODULEFILE
  
  
#############BEG      GROUP ACCESS REQUEST
  
  if [[ $GROUP_ACCESS =~ [^[:space:]] ]]; then
  
     echo ""
     echo "  -> GROUP_ACCESS variable is set.  Will allow group access to modulefile."
     echo ""
   
                          # Determine which group to use
     if [[ ! $GROUP =~ [^[:space:]] ]]; then
  
                          # Use the primary group
        GROUP=`id -gn`
        group_type="primary"
        do_chgrp=no
     else
                          # User supplied Group, make sure all it is valid
        touch /tmp/imod_test.$$
        chgrp_out=`chgrp $GROUP /tmp/imod_test.$$ 2>&1`
        if [[ $? != 0 ]]; then
           do_chgrp=no
           echo "  -> WARNING: test for changing group to $GROUP failed."
           echo "  ->          CHANGE to $GROUP will NOT be performed."
           echo "  ->          chgrp output: $chgrp_out"
           #USUAL ERROR: chgrp: changing group of ‘/tmp/imod_test....’: Operation not permitted
        else
           echo "  -> Test for changing group to $GROUP passed."
           do_chgrp=yes
        fi
        rm -rf  /tmp/imod_test.$$
  
        do_chgrp=yes
        group_type="user-supplied (in GROUP variable)"
     fi
   
   
     getent_out=`getent group $GROUP`
     group_users=`echo $getent_out | sed 's/.*://'`
     echo "  -> Processing GROUP access for $group_type group $GROUP"
     echo "  -> Members of the group are: $group_users"
     echo ""
   
     do_chmod=yes
     if [[ $MODULEFILES_DIR =~  $STOCKYARD ]]; then
        CHANGE_DIRS=(  $STOCKYARD )
        CHANGE_DIRS+=( $WORK )
        BASE_DIR=$WORK
     elif [[ $MODULEFILES_DIR =~  $HOME ]]; then
        CHANGE_DIRS+=( $HOME )
        BASE_DIR=$HOME
     else
        echo "  -> GROUP ACCESS to a directory outside of \$HOME or \$WORK is not allowed."
        echo "  ->     Your modulefiles path is $MODULEFILES_DIR"
        echo "  ->     Group permissions will not be changed to provide group access."
        do_chmod=no
     fi
  
     if [[ $do_chmod == yes ]]; then
        RELATIVE_PATH=`echo $MODULEFILES_DIR | sed 's@'$BASE_DIR'/@@'`
        
        IFS='/' read -r -a dirs <<< "$RELATIVE_PATH"
     
        DIR=$BASE_DIR
        for dir in ${dirs[@]}; do
            DIR=$DIR/$dir
            CHANGE_DIRS+=( $DIR )
        done
     
        CHANGE_DIRS+=( $MODULEFILES_DIR/$MODULE_DIR )
        CHANGE_DIRS+=( $MODULEFILES_DIR/$MODULE_DIR/$MODULE )
  
                         #Now process all directories in the array.
        if [[ $do_chgrp == yes ]]; then
            echo "  -> chmod g+rX  and chgrp $GROUP  executed on: "
        else
            echo "  -> chmod g+rX  executed on: "
        fi
        for change_dir in ${CHANGE_DIRS[@]}; do
          echo "  ->    $change_dir"
         $CMD chmod g+rX $change_dir
          if [[ $do_chgrp == yes ]]; then
             $CMD chgrp $GROUP $change_dir
          fi
        done
  
     fi
     echo ""
  fi
#############END      GROUP ACCESS REQUEST


#############BEG      MODULEFILES  ACCESS

if [[ ! "$MKMOD_DEBUG"  =~ [^[:space:]]  ]] && [[ ! "$USE_IN_BASHRC"  =~ none  ]] ; then
  echo "  -> MODULEFILES DIRECTORY ACCESS (USE):"
  echo "  -> Checking for \"module use $MODULEFILES_DIR\" in \$HOME/.bashrc."

   grep -e  "$MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT" $BASHRC >/dev/null

   if [[ $? == 0 ]]; then
      echo "  -> Note: \"module use $MODULEFILES_DIR\" is already in \$HOME/.bashrc."
      chx4="checking for "
   else
      chx4=""
      echo "  -> Note: Including \"module use $MODULEFILES_DIR\"  in \$HOME/.bashrc."
      echo "  -> Making backup \$HOME/.bashrc_mkmod_bu.$$."
      cp $HOME/.bashrc               $HOME/.bashrc_mkmod_bu.$$

      echo "  -> ********************************************************************"
      echo ""
      echo "  -> DON'T FORGET TO LOGOUT and LOGIN to activate "module use " in .bashrc"
      echo ""
      echo "  -> ********************************************************************"

      grep -P '^\s*export\s+__BASHRC_SOURCED__=1' $BASHRC > /dev/null

      if [[ $? == 0 ]]; then

   #                                            Insert Module Use after BASHRC_SOURCES if it exists
   #                                            include 4 spaces in front
         sed -i '/export __BASHRC_SOURCED__=1/a'"\ \ \ \ module use $MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT" $BASHRC

      else

   #                                            Otherwise, put the module use at the end
   #                                            Make sure it is only sourced (used) once at login
   #                                            and not in batch

         readarray message <<-EOF
           :
           :###############
           :# SECTION MKMOD
           :if [ -z "\$__MKMOD_BASHRC_SOURCED__" -a "$ENVIRONMENT" != BATCH ]; then
           :  export   __MKMOD_BASHRC_SOURCED__=1
           :  module use $MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT
           :fi
	EOF
        #Above EOF must have a tab before it, and nothing else (NO SPACES, just a tab)!

                            #lop off spaces up to and including ":", and print
         shopt -s extglob
         printf '%s' "${message[@]#+( ):}" >> $BASHRC
         shopt -u extglob
      fi

   fi
   echo "  -> Finished with $chx4 \"module use\" setup in \$HOME/.bashrc."
   echo ""
fi
#############END      MODULEFILES  ACCESS

#}
