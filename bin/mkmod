#!/bin/bash

                   # DO NOT MODIFY format "MKMOD_version=<ver>  # VERSION SOURCE"
MKMOD_VERSION=1.0  # VERSION SOURCE makefile extracts version from this line

if [[ ${BASH_SOURCE[0]} =~ [^[:space:]] ]]; then
   BASE_DIR="$(dirname "${BASH_SOURCE[0]}")"
   source $BASE_DIR/mkmod_utils
else
   echo "  -> ERROR: Could not find mkmod_utils directory"
   echo "  ->        Expecting to find it in the same directory as mkmod."
   echo "  ->        Expecting to find it in $(dirname "$0")."
   exit 1
fi

MKMOD_HELP=$(sed 's/^#//' <<'EOF'
#  mkmod builds & inserts a modulefile in $HOME/modulefiles.
#
#  The minimal work a user must do is export 3 variables and call mkmod.
#
#  e.g.  NAME=tau
#        VER=2.26.2p1
#        TOPDIR=$HOME/$NAME
#      
#        export NAME VER TOPDIR
#
#        mkmod
#
#  NAME   is the name of the package, less the version number.
#  VER    is the version of the package, usually found in the package name.
#  TOPDIR is the "top level directory" of the package (e.g. $HOME/tau-2.26.2p1)
#
#       Set MODULEFILE_DIR if you don't want to use $HOME/modulefiles.
#
#  
#  FEATURES - module creation
#       * Auto sets module name to my_<name>/<ver>
#       * Auto sets MY_<NAME>_<dir> Env Vars (dir=DOC/LIB/SHR/BIN/INC/DAT/EXM/TUT/TOL/DIR)
#                                            (these are called distro_dirs)
#                                            (use PREFIX=<whatever> in lieu of MY_/my_)
#       * Auto sets PATH/LD_LIB_PATH/MANPATH/PYTHONPATH
#       * Auto sets prereq (to whatever comp/mpi is loaded) and sets family
#       * Auto creates help_message: lists distro_dirs  & paths env var names & vals.
#                                    lists module command and pkg version.
#       * HELP_MESSAGE (env var)     included in help_message (e.g. loader instructions)
#       * help_message (file)        if found, includes file (does variable replacement).
#                                    (file is sourced if "here file" syntax observed)
#       * AUTO_HELP    (env var)     set to "none" or list one or more of set:
#                                    (dirs, paths, envs, module, version).
#  
#  FEATURES - module setup
#       * Sets up $HOME/modulefiles directory (mkdir, perms, etc.)
#       * Sets up "module use $HOME/modulefiles" in $HOME/.bashrc
#  
#  FEATURES - control and instrumentation
#       Defaults can be changed by these Environment Variables
#  
#       1.) MODULEFILES_DIR          (default= $HOME/modulefiles )
#       2.) GROUP_ACCESS             (if set, allow primary group access)
#       3.) GROUP                    (required for non-primary group)
#
#       4.) COMPILER_PREREQ          (auto default= loaded compiler)
#       5.)      MPI_PREREQ          (auto default= loaded MPI)
#       6.)     AUTO_PREREQ          (set to "none" avoid auto setting compiler/mpi prereqs.)
#       7.)          PREREQ          (sets prereqs -- space separated list)
#
#       8.) PREFIX                   (default= MY_|my_)
#       9.) FAMILY                   (default= NAME, set to "" for no family)
#
#      10.) HELP_FILE                (default= finds modules_help file relative to $TOPDIR, use this 
#                                              var to set path and name for your own help file.
#                                              Set to "none" to avoid searching for file. 
#      11.) WHATIS_FILE              (default= finds whatis_help file relative to $TOPDIR, use this 
#                                              var to set path and name for your own help file.
#                                              Set to "none" to avoid searching for file. 
#      12.) MODULEFILE_FILE          (default= finds modulefile.lua|tcl file relative to $TOPDIR, use
#                                              this var to set path and name for your own help file.
#                                              Set to "none" to avoid searching for file. 
#      13.) USE_IN_SHELLHRC          (if "none", no .<shell>rc check and insert-- e.g. use for RPMS)
#      14.) MKMOD_DEBUG              (if set, modulefile goes to std out, no check and insert of .<shell>rc)
#
#  
#       PATHS -- RELATIVE to TOPDIR
#  
#           topdir_path_list         (e.g. ="x86_64/bin")
#           topdir_ldpath_list       (e.g. ="x86_64/libraries/linpack")
#           topdir_manpath_list      (e.g. ="man linpack/man otherpkg/man")
#           topdir_pythonpath_list   (e.g. ="share/pkgs/python")
#  
#       PATHS -- FULL
#  
#           path_list                (e.g. path_list="/sbin /home1/1234/charles/bin")
#           ldpath_list              (e.g. ldpath_list="/opt/apps/papi/5.6.0/lib")
#  
#       PREREQUISITES -- must be loaded
#  
#           PREREQ                   (space separated list)
#  
#  
#       WHATIS   (not automatic)
#  
#           WHATIS                   (@-separated list. e.g.
#                                     WHATIS="Name: PETSc @ Version: 3.8 @ Category: lib")
#  
#      ENVIROMENT -- VARIABLES       (also displayed in the help message)
#  
#          ENV1="<val1>"             (e.g. ENV1="TAU=$TOPDIR/x86_64/bin")
#          ENV2="<val2>"             (e.g. ENV2="GET_TIME_OF_DAY:PAPI_TOT_CYC:PAPI_L2_LDM")
#          ENV3="<val3>"
#  
#      COMMANDS -- LUA statements
#  
#          CMD1="<cmd1>"             (e.g.LMOD CMD1="conflict(\"boost\",\"boost-mpi\")" )
#          CMD2="<cmd2>"             (e.g.LMOD CMD2="load(\"hdf5\")" )
#
#          CMD1="<cmd1>"             (e.g.TMOD CMD1="conflict boost boost-mpi" )
#          CMD2="<cmd2>"             (e.g.TMOD CMD2="load  hdf5" )
#  
#  COMPONENTS - order
#    1.) Help Message (see default, or contents of help_message file)
#    2.) whatis       (none by default, use WHATIS env var)
#    3.) family       (default $NAME_sml, use FAMILY env var)
#    4.) prereq's     (default=loaded Compiler/MPI, use COMPILER_PREREQ|MPI_PREREQ)
#    5.) prereq's     (Explicitly set)
#    6.) local topdir (definition for $TOPDIR)
#    7.) prepends     (from topdir_path|ldpath|manpath|pythonpath_list) 
#    8.) prepends     (from full path path|ldpath|manpath|pythonpath_list) 
#    9.) setenv       (from ENV1, ENV2, ..., ENV30 )
#   10.) LUA cmds     (from CMD1, CMD2, ..., CMD30)
#
#  TUTORIAL - module (LMOD)  details
#     tinyurl.com/chpc-2017-tools  (download CHPC_2017_lmod_28.pdf)
#
#                                                 author:  Kent Milfeld 2018_03_07
#  ------

EOF
)

# New Features  Version 1.0
#     Explicitly defined prereqs support               2018_01_29
#     TMOD support (by FLAVOR: lmod or tmod )          2018_02_29
#                  (automatically determined )
#     WHATIS_FILE support                              2018_03_29
#     makefile, to install mkmod and make its module   2018_03_05
#     New mkmod_utils for env. var substitution        2018_04_04
#     Remove /tmp temporary files after use            2018_04_05
#     Use $BASH_SOURCE directory for mkmod_utils       2018_04_17
#     "module use" in startup files supported 
#     for bash, csh,tcsh and zsh shells.               2018_04_18
#     Allow none for WHATIS|HELP_FILE to avoid search  2018_04_18
# TODO -- still has some TACCism that should be generalized (e.g. $WORK directory)
#tmod https://github.com/cea-hpc/modules/blob/master/doc/paper/MC2_whitney_paper.pdf

t_divider="  "
l_divider="--"

USAGE='
  USAGE: mkmod [-h|--help]

         NAME, VER and TOPDIR must be defined and exported.
  ---------------------------------------------------------
'
# v-- ARGS and ENV VARS

  if [[ $1 == "-h" ]] || [[ $1 == "--help" ]]; then
     echo "$USAGE"
     echo "$MKMOD_HELP"
     exit 0
  fi

  if [[ $1 == "-v" ]] || [[ $1 == "--version" ]]; then
     echo "VERSION=$MKMOD_VERSION"
     exit 0
  fi


  if [[ ! "$NAME"    =~ [^[:space:]]  ]] ||
     [[ ! "$VER"     =~ [^[:space:]]  ]] ||
     [[ ! "$TOPDIR"  =~ [^[:space:]]  ]] ;  then

     echo " $USAGE "
     exit 1 
  fi

# ^-- ARGS and ENV VARS

#                            # default help_message file is $TOPDIR/modules_help
# [[ ! "$HELP_FILE"  =~ [^[:space:]]  ]] && HELP_FILE=$TOPDIR/modules_help

                            # look for these compilers (names) as loaded compiler modules
  compilers=(intel gcc llvm clang open64 pgi ibmcmp)
  MPIs=(impi mvapich2 openmpi mpich)

# v-- DETERMINE if using LMOD OR TMOD

  if [[ ! $MKMOD_FLAVOR =~ [^[:space:]] ]]; then
         # Determine whether to use tmod or lmod.
         # modver=(`module --version 2>&1`)    #Uh tmodule 3.x displays version and returns "1" !
         # if [[ ! $? == "0" ]]; then
         # Use MODULESHOME variable as indicator
    if [[ ! "$MODULESHOME" =~ [^[:space:]]  ]]; then
     echo "  ->  ERROR: Found neither Tmod (TCL) nor Lmod (Lua) to exist on this machine."
     echo "  ->         mkmod supports only these flavors of modules."
     echo "  ->         Used the existence of \$MODULEHOME to determine existence of environment modules."
     echo "  ->         You can set MKMOD_FLAVOR to either Tmod or Lmod to override | force creation."
     exit 1
    else
         # Assume tmod.  If --version shows Lau, then assume lmod
     FLAVOR=tmod
     modver=(`module --version 2>&1`)
     status=$?
     if [[  $status != "0" ]] && [[  $status != "1" ]]; then
       echo "  -> ERROR: \"module --version\" didn't work." 
       echo "  ->         You can set MKMOD_FLAVOR to either Tmod or Lmod to override | force creation."
       exit 0
     fi
     [[ ${modver[@]} =~ "Lua" ]] && FLAVOR=lmod
  
     echo ""
     echo "  -> Will create a modulefile for $NAME with the $FLAVOR flavor of modules."
    fi
  
  else
    FLAVOR=$( echo $MKMOD_FLAVOR | tr '[:upper:]' '[:lower:]' )
    if [[ $FLAVOR == "lmod"  ]] || [[ $FLAVOR == "tmod"  ]] ; then
       echo "  -> Will create $FLAVOR flavored modulefile (determined by \$MKMOD_FLAVOR)."
    else
       echo "  -> ERROR: MKMOD_FLAVOR must be either Lmod or Tmod (case insensitive)."
       echo "  ->        Found $MKMOD_FLAVOR."
       exit 2
    fi
  fi

# ^-- DETERMINE if using LMOD OR TMOD


# v-- TOPDIR CHECK

  #   IF TOPDIR doesn't exist -- exit

  echo ""
  echo "  -> mkmod MODULEFILE CREATION:"
  if [[ ! -d $TOPDIR ]]; then
     echo "  -> ERROR: Could not find directory \$TOPDIR: $TOPDIR"
     echo "  ->        Application must be installed in \$TOPDIR before executing mkmod."
     exit 2
  else
     echo "  -> Found \$TOPDIR directory: $TOPDIR"
  fi

# ^-- TOPDIR CHECK

#v---- SUPPORT FILES: Find and Prepare

#        Check for MODULEFILE_FILE       MODULES_HELP, MODULES_WHATIS files
#                 (modulefile.[tcl|lua], modules_help, modules_whatis)
 
#                 modules_help and modules_whatis go into creating a modulefile
#                 modulefile.tcl or modulefile.lua are used for the modulefile

# v-- MODULEFILE_FILE

#                     # Checking for an application environment modules file (modulefile)

#                     # If MODULEFILE_FILE is NOT set, search for one in the App directory (TOPDIR).
  if [[ ! $MODULEFILE_FILE =~ [^[:space:]] ]]; then
    provided_modulefile=no

#                                            Don't look for file for these cases
#                                            e.g. mkmod has modulefile.$FLAVOR in examples
   if [[ ! $MODULEFILE_FILE == none ]] && [[ ! $NAME == mkmod ]]; then

    modulefiles=( `find $TOPDIR -name modulefile.$FLAVOR -print` )
    if [[ ${#modulefiles[@]} >  1 ]]; then
       echo "  -> ERROR: Houston, we have a problem."
       echo "  ->        Found multiple modulefile.$FLAVOR files relative to \$TOPDIR."
       echo "  ->        They are: ${modulefiles[@]}."
       echo "  ->        Set one of these files in the MODULEFILE_FILE variable (export it)."
       echo "  ->        and run mkmod again."
       exit
    fi
      [[ ${#modulefiles[@]} == 0 ]] && MODULEFILE_FILE=""
      if [[ ${#modulefiles[@]} == 1 ]]; then
         MODULEFILE_FILE=${modulefiles[0]}
         provided_modulefile=yes
         echo "  -> FOUND App modulefile: $MODULEFILE_FILE "
         echo "  -> Will NOT MAKE MAKEFILE, will use this file after performing variable substitution."
      fi
   else
         echo "  -> Will NOT LOOK FOR a modulefile.$FLAVOR file."
   fi
#                     # MODULEFILE_FILE is set, make sure it exists and is readable
  else
      provided_modulefile=yes
      if [[ -e $MODULEFILE_FILE  ]] &&  [[ -r $MODULEFILE_FILE ]]; then
        echo "  -> Permission OK on ENVIRONMENT supplied \$MODULEFILE_FILE file: $MODULEFILE_FILE."
        echo "  -> Will NOT MAKE MAKEFILE, will use this file after performing variable substitution."
      fi
  fi


  if [[ $provided_modulefile == yes ]]; then
     FILE_TYPE=modulefile
                 MODULEFILE_EVALD_FILE=/tmp/${FILE_TYPE}_evaluated_$USER.$$
     evaluate $MODULEFILE_FILE $FILE_TYPE $MODULEFILE_EVALD_FILE
  fi

  if [[ $MKMOD_DEBUG =~ [^[:space:]] ]] && [[ $provided_modulefile == yes ]]; then
     echo $'\n\n\n'"-------------------------------------------------------------------------------"
     cat "$MODULEFILE_EVALD_FILE"
     echo "-------------------------------------------------------------------------------" $'\n'
  fi

# ^-- MODULEFILE


# v-- WHATIS_FILE

#                     # If WHATIS_FILE is NOT set, search for one in the App directory (TOPDIR).
  if [[ ! $WHATIS_FILE =~ [^[:space:]] ]]; then
    provided_whatis=no

#                                            Don't look for file for these cases
#                                            e.g. mkmod has modulefile.$FLAVOR in examples
   if [[ ! $WHATIS_FILE == none ]] && [[ ! $NAME == mkmod ]]; then

    whatiss=( `find $TOPDIR -name modules_whatis -print` )
    if [[ ${#whatiss[@]} >  1 ]]; then
       echo "  -> ERROR: Houston, we have a problem."
       echo "  ->        Found multiple modules_whatis files relative to \$TOPDIR."
       echo "  ->        They are: ${whatiss[@]}."
       echo "  ->        Set one of these files in the WHATIS_FILE variable (export it)."
       echo "  ->        and run mkmod again."
       exit
    fi
      [[ ${#whatiss[@]} == 0 ]] && WHATIS_FILE=""
      if [[ ${#whatiss[@]} == 1 ]]; then
         WHATIS_FILE=${whatiss[0]}
         provided_whatis=yes
         echo "  -> FOUND whatis file: $WHATIS_FILE "
         echo "  -> Will create whatis entries after performing variable substitution on this file."
      fi
   else
         echo "  -> Will NOT LOOK FOR a modules_whatis file"
   fi
#                     # WHATIS_FILE is set, make sure it exists and is readable
  else
      provided_whatis=yes
      if [[ -e $WHATIS_FILE  ]] &&  [[ -r $WHATIS_FILE ]]; then
        echo "  -> Permission OK on \$WHATIS_FILE: $WHATIS_FILE file."
        echo "  -> Will create whatis entries after performing variable substitution on this file."
      fi
  fi


  if [[ $provided_whatis == yes ]]; then
     FILE_TYPE=whatis
     WHATIS_EVALD_FILE=/tmp/${FILE_TYPE}_evaluated_$USER.$$
     evaluate $WHATIS_FILE $FILE_TYPE $WHATIS_EVALD_FILE
  fi

  if [[ $MKMOD_DEBUG =~ [^[:space:]] ]] && [[ $provided_whatis == yes ]]; then
     echo $'\n\n\n'"-------------------------------------------------------------------------------"
     cat "$WHATIS_EVALD_FILE"
     echo "-------------------------------------------------------------------------------" $'\n'
  fi

# ^-- WHATIS_FILE


# v-- HELP_FILE

#                     # If HELP_FILE is NOT set, search for one in the App directory (TOPDIR).
  if [[ ! $HELP_FILE =~ [^[:space:]] ]]; then
    provided_help=no

#                                            Don't look for file for these cases
#                                            e.g. mkmod has modulefile.$FLAVOR in examples
   if [[ ! $HELP_FILE == none ]] && [[ ! $NAME == mkmod ]]; then

    helps=( `find $TOPDIR -name modules_help -print` )
    if [[ ${#helps[@]} >  1 ]]; then
       echo "  -> ERROR: Houston, we have a problem."
       echo "  ->        Found multiple modules_help files relative to \$TOPDIR."
       echo "  ->        They are: ${helps[@]}."
       echo "  ->        Set one of these files in the HELP_FILE variable (export it)."
       echo "  ->        and run mkmod again."
       exit
    fi
      [[ ${#helps[@]} == 0 ]] && HELP_FILE=""
      if [[ ${#helps[@]} == 1 ]]; then
         HELP_FILE=${helps[0]}
         provided_help=yes
         echo "  -> FOUND help file: $HELP_FILE "
         echo "  -> Will create help entries after performing variable substitution on this file."
      fi
   else
         echo "  -> Will NOT LOOK FOR a modules_help file."
   fi 
#                     # HELP_FILE is set, make sure it exists and is readable
  else
      provided_help=yes
      if [[ -e $HELP_FILE  ]] &&  [[ -r $HELP_FILE ]]; then
        echo "  -> Permission OK on \$HELP_FILE: $HELP_FILE file."
        echo "  -> Will create help entries after performing variable substitution on this file."
      fi
  fi


  if [[ $provided_help == yes ]]; then
     FILE_TYPE=help
     HELP_EVALD_FILE=/tmp/${FILE_TYPE}_evaluated_$USER.$$
     evaluate $HELP_FILE $FILE_TYPE $HELP_EVALD_FILE
  fi

  if [[ $MKMOD_DEBUG =~ [^[:space:]] ]] && [[ $provided_whatis == yes ]]; then
     echo $'\n\n\n'"-------------------------------------------------------------------------------"
     cat "$HELP_EVALD_FILE"
     echo "-------------------------------------------------------------------------------" $'\n'
  fi

# ^-- HELP_FILE

#^---- SUPPORT FILES: Find and Prepare


#v---- Modulefile Prep

# v-- Modulefile Directory
  #                          #Optional Values,  TACC Staff agree on these defaults
  
  #                          # Best to have a prefix so as not to confuse
  #                          # with production version
  #                          # (e.g. ml intel/18.0.0    gamess #production version)
  #                          # (e.g. ml intel/18.0.0 my_gamess #personal   version)

  #https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
                        #PREFIX NOT DEFINE, (does not include "")
  if [[ -z "${PREFIX+x}" ]]; then
     PREFIX_sml=my_
     PREFIX_cap=MY_
  else                    #USER-DEFINED PREFIX (may include "" -- which means NO prefix)
     PREFIX_cap=$( echo $PREFIX | tr '[:lower:]' '[:upper:]' )
     PREFIX_sml=$( echo $PREFIX | tr '[:upper:]' '[:lower:]' )
  fi

  echo "  -> Prefix for module is \"$PREFIX_sml\". (Set PREFIX=\"\" for none.)"

  
  if [[ ! "$MODULEFILES_DIR"  =~ [^[:space:]]  ]]; then

     MODULEFILES_DIR=$HOME/modulefiles      # Default place to put modulefiles
  fi   

  DIR_ABOVE=$(dirname $MODULEFILES_DIR) # Make sure usr can write to $MODULEFILES_DIR/..
  test -w $DIR_ABOVE 
  if [[  $? != 0 ]]; then
     echo "  -> ERROR:  Cannot write into directory ABOVE: $MODULEFILES_DIR"
     echo "  ->         Is the intended modulesfile directory, $MODULEFILES_DIR?"
     echo "  ->         If it is, please allow write permission to $DIR_ABOVE."
     exit 9
  fi

  #                          # Internal Variables are set here
  
         NAME_cap=$( echo $NAME | tr '[:lower:]' '[:upper:]' )
         NAME_sml=$( echo $NAME | tr '[:upper:]' '[:lower:]' )
  
       MODULE_DIR=$MODULEFILES_DIR/${PREFIX_sml}$NAME_sml
  if [[ $FLAVOR == "lmod" ]]; then
            MODULE=${VER}.lua
  else
            MODULE=${VER}
  fi
  
            BASHRC=$HOME/.bashrc
  
  #                          # Preparations here

  #   IF MODULE_DIR is accessible (mkdir -p)  -- exit otherwise
  
  mkdir -p $MODULE_DIR    #no-op if already exists and writable
  if [[ ! $? ]]; then
     echo "  -> ERROR: Could not use \$MODULE_DIR: $MODULE_DIR"
     echo "  ->        Please correct and rerun $0."
     exit 3
  else
     echo "  -> Able to access|create \$MODULE_DIR: $MODULE_DIR"
  fi

# ^-- Modulefile Directory

# v-- Help Message

  #                          # Specialized Variables used in the modulefile
  #                          # Give values if not defined by user

  HELP_MESSAGE_INC=none    #default, no module_help to be included
  help_env_text=no

  [[ $provided_help == yes ]] &&  echo "  -> Including help message from $HELP_FILE file."

  if [[ "$HELP_MESSAGE"  =~ [^[:space:]]  ]]; then
     HELP_MESSAGE_INC=message
     help_env_text=yes
     if [[ $provided_help == yes ]]; then
        echo "  -> NOTICE:  Found \$HELP_MESSAGE environment variable."
        echo "  ->          AND a help file ($HELP_FILE) exists."
        echo "  -> Including help message from text in \$HELP_MESSAGE."
     else
        echo "  -> Will include help message from text in \$HELP_MESSAGE." 
     fi
  fi

  #                          # If AUTO_HELP is spaces or not defined, help messages are automatically
  #                          # created for distro_dirs, PATH variables insertion, environment variables
  #                          # module usage (including prerequisites, and version, respectively:
  #                          # ( dirs paths envs module version )
  #                          
  if [[ ! $AUTO_HELP =~ [^[:space:]] ]]; then
                        # Include all automatic help messages
     AUTO_HELP_INC=( dirs paths envs module version )

  else
                        # if value is "none" then make AUTO_HELPER empty
     if [[ $AUTO_HELP =~ none ]]; then
        AUTO_HELP_INC=""
     else
                        # If not "none", then AUTO_HELP must have a list of automatic
                        # message names (from this list: dirs paths envs module version ).
                        # From this list make an array in AUTO_HELP_INC.
        IFS=' ' read -r -a AUTO_HELP_INC <<< "$AUTO_HELP"
     fi
  fi

# ^-- Help Message


# v-- Family

  if [[ ! "$FAMILY"        =~ [^[:space:]]  ]]; then
     FAMILY=$NAME_sml
  else
     [[ $FAMILY == none ]] && FAMILY=""   # exception, no family if "none"
  fi
  
  #                          # Defaults: set env VARS: <prefix><NAME>_DIR and <prefix><NAME>_BIN
  #                          # Defaults: add bin directory to PATH

# ^-- Family

# v-- ENV VARS
  # topdir_env_list
  
       if [[ ! "$topdir_env_list"  =~ [^[:space:]] ]] ; then
         #topdir_env_default=( bin lib libs inc man doc docs )
          topdir_env_default=( bin lib libs lib64 include man doc docs share tools bench benchmark data Examples examples tutorials)

          topdir_env_list=(dir)   # This must exist!  dir mean "topdir"
          for dir in ${topdir_env_default[@]}; do
            [[ -d $TOPDIR/$dir ]] && topdir_env_list+=($dir)
          done

          echo "  -> Autocheck found these directories in \$TOPDIR: ${topdir_env_list[@]}"
          echo "  ->           Will create ${PREFIX_cap}${NAME_cap}_<DIR> environment vars for these."
       else
          topdir_env_string=$topdir_env_list
          topdir_env_list=()
          IFS=' ' read -r -a topdir_env_list <<<$topdir_env_string
       fi

# ^-- ENV VARS
 
# v-- TOPDIR PATHS

       if [[ ! "$topdir_path_list" =~ [^[:space:]]  ]]; then
          if [[ -d $TOPDIR/bin ]]; then
             topdir_path_list+=(bin)
             echo "  -> Autocheck found bin in \$TOPDIR."
             echo "  ->           Will include in PATH."
          fi
          if [[ -d $TOPDIR/scripts ]]; then
             topdir_path_list+=(scripts)
             echo "  -> Autocheck found scripts in \$TOPDIR."
             echo "  ->           Will include in PATH."
          fi
       else
          topdir_path_string=$topdir_path_list 
          topdir_path_list=()
          IFS=' ' read -r -a topdir_path_list <<<$topdir_path_string
       fi

# ^-- TOPDIR PATHS

# v-- TOPDIR LD_LIBRARY_PATHS

       if [[ ! "$topdir_ldpath_list" =~ [^[:space:]]  ]]; then
          [[ -d $TOPDIR/lib   ]] && topdir_ldpath_list=(lib)
          [[ -d $TOPDIR/libs  ]] && topdir_ldpath_list=(libs)
          [[ -d $TOPDIR/lib64 ]] && topdir_ldpath_list=(lib64)
          if [[ ${#topdir_ldpath_list[@]} > 0 ]] ;then
             echo "  -> Autocheck found ${topdir_ldpath_list[@]} in \$TOPDIR."
             echo "  ->           Will include in LD_LIBRARY_PATH."
          fi
       else
          topdir_ldpathstring=$topdir_ldpathlist
          topdir_ldpathlist=()
          IFS=' ' read -r -a topdir_ldpathlist <<<$topdir_ldpathstring
       fi

# ^-- TOPDIR LD_LIBRARY_PATHS

# v-- TOPDIR MAN_PATHS

       if [[ ! "$topdir_manpath_list" =~ [^[:space:]]  ]]; then
          if [[ -d $TOPDIR/man ]]; then
             topdir_manpath_list=(man)
             echo "  -> Autocheck found man in \$TOPDIR."
             echo "  ->           Will include in MANPATH."
          fi
       else
          topdir_manpath_string=$topdir_manpath_list
          topdir_manpath_list=()
          IFS=' ' read -r -a topdir_manpath_list <<<$topdir_manpath_string
       fi

# ^-- TOPDIR MAN_PATHS
  

# v-- TOPDIR PYTHONPATHS


       if [[ ! "$topdir_pythonpath_list" =~ [^[:space:]]  ]]; then
          if [[ -d $TOPDIR/python ]]; then
             topdir_pythonpath_list=(python)
             echo "  -> Autocheck found python in \$TOPDIR."
             echo "  ->           Will include in PYTHONPATH."
          fi
       else
          topdir_pythonpath_string=$topdir_pythonpath_list
          topdir_pythonpath_list=()
          IFS=' ' read -r -a topdir_pythonpath_list <<<$topdir_pythonpath_string
       fi

  
       echo "  -> Modulefile  ${MODULE_prefix}$NAME_sml/$MODULE  will go in $MODULEFILES_DIR" 

# ^-- TOPDIR PYTHONPATHS

#^---- Modulefile Prep         

#v---- Modulefile Creation
  
 module=()
 #               #Will include help_message string here later 
 #               #This helps with debugging when message is long.

 if [[ $FLAVOR == "lmod" ]]; then
     module+=( "help(help_msg,\"\\n\")" )
     module+=( "$l_divider" )
 fi


# v-- WHATIS

  whatis_env_text=no
  if [[ "$WHATIS" =~ [^[:space:]]  ]]; then
     whatis_env_text=yes
     echo "  -> Including \"whatis\" information in the modulefile."

     IFS='@' read -r -a lines <<< $WHATIS

     for text in "${lines[@]}"; do
                         #trim text
        shopt -s extglob
        a="${text##*( )}"; trimmed_text="${a%%*( )}"
        shopt -u extglob
       if [[ $FLAVOR == "lmod" ]]; then
        module+=( "whatis(\"$trimmed_text\")" )
       else
        module+=( "module-whatis \"$trimmed_text\"" )
       fi # flavor

     done
  fi

                # Version 1 now uses numbered variables (WHATIS1, WHATIS2,...)
  if [[  "$WHATIS1"  =~ [^[:space:]] ]]; then  #only do if WHATISx exist
     whatis_env_text=yes
     for i in `seq 1 30`; do
       text=$( eval echo \"\$WHATIS$i\" )
       if [[  "$text"  =~ [^[:space:]] ]]; then
         shopt -s extglob
         a="${text##*( )}"; trimmed_text="${a%%*( )}"
         shopt -u extglob

        if [[ $FLAVOR == "lmod" ]]; then
         module+=( "whatis(\"$trimmed_text\")" )
        else
         module+=( "module-whatis \"$trimmed_text\"" )
        fi
       fi
     done
  fi

  if [[ $provided_whatis == yes ]] && [[ $whatis_env_text == yes ]]; then
       echo "  -> NOTICE:   Supplied environment variable \$WHATIS has whatis information and"
       echo "  ->           there is a also a file, $WHATIS_FILE,"
       echo "  ->           that contains whatis information."
       echo "  ->           ONLY the \$WHATIS environment variable informat will be used, to avoid"
       echo "  ->           any conflict."

       echo "  ->           You might want to view the information in the"
       echo "  ->           $WHATIS_FILE file,"
       echo "  ->           and include information from it in your \$WHATIS environment variable."
       echo "  ->           Or, possibly only use the file information by unsetting \$WHATIS."
  fi

  if [[ $whatis_env_text == yes ]]; then
     echo "  -> Including whatis info from \$WHATIS environment variable."
  fi

  if [[ $provided_whatis == yes ]] && [[ $whatis_env_text == no ]]; then

     echo "  -> Including whatis info from $WHATIS_FILE file."
     echo "  ->       Evaluated version is $WHATIS_EVALD_FILE file."
     while IFS= read -r text; do
        shopt -s extglob
        a="${text##*( )}"; trimmed_text="${a%%*( )}"
        shopt -u extglob
#                             #Don't want blank lines.
        if [[ $trimmed_text =~ [^[:space:]] ]]; then
          if [[ $FLAVOR == "lmod" ]]; then
             module+=( "whatis(\"$trimmed_text\")" )
          else
             module+=( "module-whatis \"$trimmed_text\"" )
          fi
        fi
     done < $WHATIS_EVALD_FILE

  fi

# ^-- WHATIS


  [[ $FLAVOR == "lmod" ]] && module+=( "$l_divider" )
  [[ $FLAVOR == "tmod" ]] && module+=( "$t_divider" )
  
  if [[ $FLAVOR == "lmod" ]] ; then
     [[ "$FAMILY" =~ [^[:space:]]  ]]&&  module+=( "family(\"$FAMILY\")" )
  fi


# v-- PREREQs
 
  if [[ ! "$AUTO_PREREQ" =~ none  ]]; then

   if [[ $FLAVOR == "lmod" ]]; then
 
#   v-COMPILER lmod

    comp_mpi_prereq=()

    if [[ ! "$COMPILER_PREREQ" =~ [^[:space:]]  ]]; then
      if [[ "$LMOD_FAMILY_COMPILER_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_COMPILER" =~ [^[:space:]] ]]; then
        COMPILER_PREREQ=$LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION
        echo "  -> Setting COMPILER PREREQ to $LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION"
        comp_mpi_prereq=( "$COMPILER_PREREQ" )
       #module+=( "prereq(\"$COMPILER_PREREQ\")" )
      fi
    else  # COMPILER_PREREQ set
      if [[ "$LMOD_FAMILY_COMPILER_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_COMPILER" =~ [^[:space:]] ]]; then
          if [[ $LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION != $COMPILER_PREREQ ]]; then
            echo ""
            echo "  -> WARNING:"
            echo "  ->         COMPILER PREREQ=$COMPILER_PREREQ"
            echo "  ->   BUT   LMOD_FAMILY_COMPILER/LMOD_FAMILY_COMPILER_VERSION=$LMOD_FAMILY_COMPILER/$LMOD_FAMILY_COMPILER_VERSION"
            echo ""
          fi
      fi
     #module+=( "prereq(\"$COMPILER_PREREQ\")" )
     comp_mpi_prereq="$COMPILER_PREREQ"
    fi

#   ^-COMPILER lmod
  
  
#   v-MPI lmod

    if [[ ! "$MPI_PREREQ" =~ [^[:space:]]  ]]; then
  
      if [[ "$LMOD_FAMILY_MPI_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_MPI" =~ [^[:space:]] ]]; then
        MPI_PREREQ=$LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION
        echo "  -> Setting MPI PREREQ to $LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION"
        comp_mpi_prereq+=( "$MPI_PREREQ" )
        #module+=( "prereq(\"$MPI_PREREQ\")" )
      fi
  
    else  # MPI_PREREQ set
  
      if [[ "$LMOD_FAMILY_MPI_VERSION" =~ [^[:space:]] ]] && [[ "$LMOD_FAMILY_MPI" =~ [^[:space:]] ]]; then
          if [[ $LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION != $MPI_PREREQ ]]; then
            echo "" 
            echo "  -> WARNING:"
            echo "  ->         MPI PREREQ=$MPI_PREREQ"
            echo "  ->   BUT   LMOD_FAMILY_MPI/LMOD_FAMILY_MPI_VERSION=$LMOD_FAMILY_MPI/$LMOD_FAMILY_MPI_VERSION"
            echo ""
          fi
      fi
      comp_mpi_prereq+=( "$MPI_PREREQ" )
      #module+=( "prereq(\"$MPI_PREREQ\")" )
    fi
 
    if [[ "$comp_mpi_prereq" =~ [^[:space:]]  ]]; then
      list=""; comma=""
      for prereq in "${comp_mpi_prereq[@]}"; do
        list="${list}${comma} \"$prereq\""
        comma=","
      done
  
      module+=( "prereq($list)" )
  
    fi

#   ^-MPI lmod
 
   else # ^--lmod  v--tmod

#   v-COMPILER tmod
                           #Find the loaded compilers
    loaded_compilers=()
    comp_count=0
    IFS=':' read -r -a loaded_compilers <<< "$LOADEDMODULES"
    for loaded_compiler in  "${loaded_compilers[@]}"; do
       for compiler in  "${compilers[@]}"; do
         #if [[ $loaded_compiler =~ "$compiler/" ]]; then
          if [[ ${loaded_compiler%%/*} =~ "$compiler" ]]; then
             comp_count=$(( comp_count + 1 ))
             [[ $MKMOD_DEBUG =~ [^[:space:]] ]] &&  
                echo "Found compiler=$compiler  loaded_compiler=$loaded_compiler"
          fi
       done
 
    done
 
 
    if [[ ! "$COMPILER_PREREQ" =~ [^[:space:]]  ]]; then
 
       if (( $comp_count > 1 )); then
          echo "  -> ERROR:  Houston, we have a problem."
          echo "  ->         Found two compilers loaded at the same time:"
          echo "  ->         ${loaded_compilers[@]}"
          echo "  ->         If you need this export \$COMPILER_PREREQ with:"
          echo "  ->         ${loaded_compilers[@]}"
          exit
       fi
 
       if (( $comp_count == 1 )); then
          module+=( "prereq ccc1 ${loaded_compilers[0]}" )
       fi
 
 
    else  # COMPILER_PREREQ set
 
                           #COMPILER_PREREQ must be a specific compiler
                           #allow corner case of multiple compilers for COMPILER_PREREQ
     matches=0
     IFS=' ' read -r -a prereq_compilers <<< "$COMPILER_PREREQ"
 #                              echo "prereq_compilers=${prereq_compilers[@]}"
 
                           # Check for matching loaded compiler(s) 
     for prereq_compiler in "${prereq_compilers[@]}"; do
       for loaded_compiler in  "${loaded_compilers[@]}"; do
          if [[ $prereq_compiler == "$loaded_compiler" ]]; then
             matches=$(( matches + 1 ))
          fi
       done
     done
  
                           # disparity between what is loaded and prereq-requested, then point this out.
     if (( ${#loaded_compilers[@]} != ${#prereq_compilers[@]} || ${#prereq_compilers[@]} != $matches )); then
                           #User specified Compiler PREREQ didn't match loaded compilers
                           #Make sure user knows about this JIC.
        echo "  -> FYI:" 
        echo "  ->      PREREQ           compilers: ${prereq_compiler[@]} "
        echo "  ->      Presently loaded compilers: ${loaded_compilers[@]} "
        echo ""
     fi
 
     echo "  -> Including Compiler Prerequite:  ${prereq_compiler[@]} "
     for prereq_compiler in "${prereq_compilers[@]}"; do
        module+=( "prereq ccc2 $prereq_compiler" )
     done
 
    fi #end NO-COMPILER_PREQ  COMPILER_PREQ

#   ^-COMPILER tmod


#   v-MPI tmod
                            #Find the loaded MPIs
    loaded_MPIs=()
    loaded_MODs=()
    MPI_loaded_cnt=0
    IFS=':' read -r -a loaded_MODs <<< "$LOADEDMODULES"
    for loaded_MOD in  "${loaded_MODs[@]}"; do
 
       for MPI in  "${MPIs[@]}"; do
          if [[ ${loaded_MOD%%/*} =~ "$MPI" ]]; then
             MPI_loaded_cnt=$(( MPI_loaded_cnt + 1 ))
             loaded_MPIs+=( $loaded_MOD )
             [[ $MKMOD_DEBUG =~ [^[:space:]] ]] &&  
                echo "Found MPI=$MPI  loaded_MPI=$loaded_MPI"
          fi
       done
 
    done
                          #MPI_PREREQ must be a specific MPI
                          #Only 1 is ever allowed
    if [[ $MPI_loaded_cnt > 1 ]] && [[ ! "$MPI_PREREQ" =~ [^[:space:]]  ]]; then
       echo "  -> ERROR:  Houston, we have a problem."
       echo "  ->         Found two or more MPIs loaded at the same time:"
       echo "  ->         ${loaded_MPIs[@]}"
       echo "  ->         To circumvent this set one MPI in the \$MPI_PREREQ variable."
       echo "  ->                  and the other MPI in the generic \$PREREQ variable."
       exit
    fi
 
    if [[ ! "$MPI_PREREQ" =~ [^[:space:]]  ]]; then 
 
     if [[ $MPI_loaded_cnt > 0 ]]; then
       module+=( "prereq ${loaded_MPIs[0]}" )
     fi
 
    else  # MPI_PREREQ set
 
       matches=0           # Check for matching loaded MPI(s) 
       for loaded_MPI in  "${loaded_MPIs[@]}"; do
          if [[ "$MPI_PREREQ" == "$loaded_MPI" ]]; then
             matches=$(( matches + 1 ))
          fi
       done
                           #User specified MPI PREREQ must match loaded MPIs
                           #If note, make sure user knows about this JIC.
     if [[ $matches == 0 ]] && [[ $MPI_loaded_cnt > 0 ]]; then
        echo "  -> FYI:"
        echo "  ->      PREREQ           MPI: $MPI_PREREQ "
        echo "  ->      Presently loaded MPI: ${loaded_MPIs[@]} "
        echo ""
     fi
 
     echo "  -> Including MPI Prerequite:  $MPI_PREREQ "
     module+=( "prereq $MPI_PREREQ" )
     ######END--^ tmod   MPI
 
    fi   #end if else MPI NOPREREQ | PREREQ

#   ^-MPI tmod
 
   fi   #end if else lmod | tmod
 
  fi   #end if not AUTO_PREREQ=none

# ^-- PREREQs

               #Now add explict PREREQS

  if [[ $PREREQ =~ [^[:space:]] ]]; then
    IFS=' ' read -r -a prereqs <<< "$PREREQ"
    for prereq in  "${prereqs[@]}"; do
      if [[ $FLAVOR == "lmod" ]]; then
        module+=("prereq( \"$prereq\" )" ) 
      else
        module+=("prereq $prereq" ) 
      fi
    done
  fi


# v-- TOPDIR

  ## TOPDIR (as a local variable)
  if [[ $FLAVOR == "lmod" ]]; then
    module+=( "$l_divider" )
    module+=("     local topdir   = \"$TOPDIR\"")
    module+=( "$l_divider" )
  else
    module+=( "$t_divider" )
    module+=(  "     set topdir     \"$TOPDIR\"")
    module+=( "$t_divider" )
  fi

# ^-- TOPDIR
  
# v-- Default Package Variables
# # DEFAULT package variable (e.g. of form MY_PKGNAME_DIR=<directory> )

  at=""; bs=""
 #[[ $FLAVOR == "tmod" ]] && bs="\\"
  [[ $FLAVOR == "tmod" ]] && bs=""

  for dir in ${topdir_env_list[@]}; do
     DIR=$( echo $(basename $dir) | tr '[:lower:]' '[:upper:]' )
     #TACC Convention (no S)
     [[ $DIR == "DOCS"     ]] && DIR=DOC; [[ $DIR == "SHARE"      ]] && DIR=SHR
     [[ $DIR == "BENCH"    ]] && DIR=BEN; [[ $DIR == "BENCHMARK"  ]] && DIR=BEN
     [[ $DIR == "TOOLS"    ]] && DIR=TOL; 
     [[ $DIR == "INCLUDE"  ]] && DIR=INC; 
     [[ $DIR == "DATA"     ]] && DIR=DAT; 
     [[ $DIR == "LIBS"     ]] && DIR=LIB; [[ $DIR == "LIB64"      ]] && DIR=LIB
     [[ $DIR == "EXAMPLES" ]] && DIR=EXM; [[ $DIR == "TUTORIALS"  ]] && DIR=TUT

     if [[ $dir =~ dir   ]]; then
       if [[ $FLAVOR == "lmod" ]]; then
        module+=( "setenv(\"${PREFIX_cap}${NAME_cap}_${DIR}\", topdir)" )
       else
        module+=( "setenv   ${PREFIX_cap}${NAME_cap}_${DIR}  \$topdir"  )
       fi
        DISTRO_DIRS+=" $at $bs\$${PREFIX_cap}${NAME_cap}_${DIR}      $TOPDIR";      at="@"
     else
       if [[ $FLAVOR == "lmod" ]]; then
        module+=( "setenv(\"${PREFIX_cap}${NAME_cap}_${DIR}\", pathJoin(topdir,\"$dir\"))" )
       else
        module+=( "setenv   ${PREFIX_cap}${NAME_cap}_${DIR}           \$topdir/$dir" )
       fi
        DISTRO_DIRS+=" $at $bs\$${PREFIX_cap}${NAME_cap}_${DIR}      $TOPDIR/$dir"; at="@"
     fi

  done
# ^-- Default Package Variables


# v-- DEFAULT PATH

# # DEFAULT path environment variables (path relative to $TOPDIR)

    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "$l_divider" )
    else
     module+=( "$t_divider" )
    fi
  
                             # If no topdir bin directory exist, put topdir in PATH
                                                          at=""
  if [[ ! "$topdir_path_list" =~ [^[:space:]]  ]]; then  
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"PATH\", topdir)" )
    else
     module+=( "prepend-path   PATH  \$topdir" )
    fi
     module+=( " " )

     PATH_DIRS+=" $at $bs\$PATH               $TOPDIR" ;      at="@"
                          #123456789012345....^
  fi
  
  for dir in ${topdir_path_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"PATH\", pathJoin(topdir,\"$dir\"))" )
    else
     module+=( "prepend-path   PATH           \$topdir/$dir" )
    fi

     PATH_DIRS+=" $at $bs\$PATH               $TOPDIR/$dir" ; at="@"
                          #123456789012345....^
  done
  
  for dir in ${topdir_ldpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"LD_LIBRARY_PATH\", pathJoin(topdir,\"$dir\"))" )
    else
     module+=( "prepend-path   LD_LIBRARY_PATH           \$topdir/$dir" )
    fi

     PATH_DIRS+=" $at $bs\$LD_LIBRARY_PATH    $TOPDIR/$dir" ; at="@"
                          #123456789012345....^
  done
  
  for dir in ${topdir_manpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"MANPATH\", pathJoin(topdir,\"$dir\"))" )
    else
     module+=( "prepend-path   MANPATH           \$topdir/$dir" )
    fi

     PATH_DIRS+=" $at $bs\$MANPATH            $TOPDIR/$dir" ; at="@"
                          #123456789012345....^
  done

  for dir in ${topdir_pythonpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"PYTHONPATH\", pathJoin(topdir,\"$dir\"))" )
    else
     module+=( "prepend-path   PYTHONPATH           \$topdir/$dir" )
    fi

     PATH_DIRS+=" $at $bs\$PYTHONPATH        $TOPDIR/$dir" ; at="@"
                       #123456789012345...^
  done

     module+=( " " )
  
# ^-- DEFAULT PATH
  
# v-- USER-DEFINED PATH
# # USER-DEFINED path environment variables (full path)

  for dir in ${path_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"PATH\",\"$dir\")" )
    else
     module+=( "prepend-path   PATH     $dir" )
    fi

     PATH_DIRS+=" $at $bs\$PATH               $dir" ; at="@"
                          #123456789012345....^
  done
  
  for dir in ${ldpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"LD_LIBRARY_PATH\",\"$dir\")" )
    else
     module+=( "prepend-path   LD_LIBRARY_PATH     $dir" )
    fi

     PATH_DIRS+=" $at $bs\$LD_LIBRARY_PATH    $dir" ; at="@"
                          #123456789012345....^
  done
  for dir in ${manpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"MANPATH\",\"$dir\")" )
    else
     module+=( "prepend-path   MANPATH     $dir" )
    fi

     PATH_DIRS+=" $at $bs\$MANPATH            $dir" ; at="@"
                          #123456789012345....^
  done
  for dir in ${pythonpath_list[@]}; do
    if [[ $FLAVOR == "lmod" ]]; then
     module+=( "prepend_path(\"PYTHONPATH\",\"$dir\")" )
    else
     module+=( "prepend-path   PYTHONPATH     $dir" )
    fi

     PATH_DIRS+=" $at $bs\$PYTHONPATH         $dir" ; at="@"
                          #123456789012345....^
  done
  
  
  if [[ "$MKMOD_DEBUG"  =~ [^[:space:]]  ]]; then
       FILE=/tmp/${USER}_${MODULE}_$$
  else
       FILE=$MODULE_DIR/$MODULE
  fi

# ^-- USER-DEFINED PATH

# v-- HELP MESSAGES
# # begin Gather all help messages together

  if [[ ${AUTO_HELP_INC[@]} =~ module ]]; then
     HELP_MODULE=$'\n   '"USAGE -- MODULES"
    #HELP_MODULE+=$'\n   '
    if [[ $FLAVOR == "lmod" ]]; then
     HELP_MODULE+=$'\n   '" Required Modules"
     HELP_MODULE+=$'\n   '" module load $COMPILER_PREREQ $MPI_PREREQ       (required if not system defaults)"
     HELP_MODULE+=$'\n   '
    fi
     HELP_MODULE+=$'\n   '" Application Modules"
    #HELP_MODULE+=$'\n   '
    #HELP_MODULE+=$'\n   '" module load $MODULE"
     HELP_MODULE+=$'\n   '" module load ${PREFIX_sml}$NAME_sml/$MODULE"
     HELP_MODULE+=$'\n'

  fi

  if [[ ${AUTO_HELP_INC[@]} =~ dirs ]]; then
     HELP_DIRS=""
     HELP_DIRS+=$'\n   ENV VAR - INFO'
     HELP_DIRS+=$'\n    '"\$${PREFIX_cap}${NAME_cap}_VER      $VER"
     HELP_DIRS+=$'\n    '"\$${PREFIX_cap}${NAME_cap}_MOD      $MODULE_DIR/$MODULE"


     HELP_DIRS+=$'\n'
     HELP_DIRS+=$'\n   ENV VAR - DISTRO        (SUB)DIRECTORY'

     IFS='@' read -r -a text <<< "$DISTRO_DIRS"
     for text in "${text[@]}"; do
                         #trim text
        shopt -s extglob
        a="${text##*( )}"; trimmed_text="${a%%*( )}"
        shopt -u extglob
        HELP_DIRS+=$'\n    '"$trimmed_text"

     done
     [[ ${#text[@]} > 0 ]] && HELP_DIRS+=$'\n'

  fi


  if [[ ${AUTO_HELP_INC[@]} =~ paths ]]; then
     HELP_PATHS=""
     HELP_PATHS+=$'\n   ENV PATH VAR                 DIRECTORY ADDED'

     IFS='@' read -r -a text <<< "$PATH_DIRS"
     for text in "${text[@]}"; do
                         #trim text
        shopt -s extglob
        a="${text##*( )}"; trimmed_text="${a%%*( )}"
        shopt -u extglob
        HELP_PATHS+=$'\n    '"$trimmed_text"

     done
     [[ ${#text[@]} > 0 ]] &&  HELP_PATHS+=$'\n'

  fi

                    # Include user-defined environment variables
  if [[ ${AUTO_HELP_INC[@]} =~ envs ]]; then
     if [[  "$ENV1"  =~ [^[:space:]] ]]; then  #only do if ENVx exist
        HELP_ENVS=$'\n   ENV VAR - SUPPORT' 
        for i in `seq 1 30`; do
          env=$( eval echo \"\$ENV$i\" )
          if [[  "$env"  =~ [^[:space:]] ]]; then
            IFS='= ' read -r key val <<< "$env"
           #line=$(printf "%20s = %s" "$key" "$val")
            line=$(printf "    %-17s = %s" "$key" "$val")
            HELP_ENVS+=$'\n'"$line"
          fi
        done
        HELP_ENVS+=$'\n'
     fi
  fi

  if [[ ${AUTO_HELP_INC[@]} =~ version ]]; then
     HELP_VERSION=$'\n'"   $NAME_sml Version: $VER"$'\n'
    #HELP_VERSION="   $NAME_sml Version: $VER"$'\n'
  fi
 
 
  if [[ "$MKMOD_DEBUG" =~ [^[:space:]] ]]; then
     echo "  ->> MKMOD_DEBUG: These AUTOMATIC HELP MESSAGES were selected to include in the modulefile:"
     echo "  ->>              ${AUTO_HELP_INC[@]}"
    #echo "$HELP_DIRS" "$HELP_PATHS" "$HELP_ENVS" "$HELP_MODULE" "$HELP_MESSAGE" "$HELP_VERSION" 
  fi

# ^-- HELP MESSAGES



#############BEG--v      CREATE MODULEFILE

# v-- CREATE MODULE
# # vvv NOW (finally) INSERT  appropriate content into the module file ($FILE)
  echo "  -> Creating $MODULE.  Full path = $MODULE_DIR/$MODULE"

  rm -f $FILE; touch $FILE
                     # Include help message
  if [[ $FLAVOR == "lmod" ]]; then
    echo "-------------------------------------------------------"     >> $FILE
    echo "-- generated by mkmod $MKMOD_VERSION   user: $USER --"       >> $FILE
    echo "-------------------------------------------------------"     >> $FILE
  else
    echo "#%Module1.0"                                                 >> $FILE
    echo "#######################################################"     >> $FILE
    echo "## generated by mkmod $MKMOD_VERSION   user: $USER ##"       >> $FILE
    echo "#######################################################"     >> $FILE
  fi
 
  echo ""                                                              >> $FILE
 
  if [[ $FLAVOR == "lmod" ]]; then
    echo "local help_msg = [[ "                                        >> $FILE
  else
    echo "proc ModulesHelp { } { "                                     >> $FILE
    echo "puts { "                                                     >> $FILE
  fi
 
  [[ ${AUTO_HELP_INC[@]}     =~ dirs        ]] && echo "$HELP_DIRS"    >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ paths       ]] && echo "$HELP_PATHS"   >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ envs        ]] && \
  [[ "$ENV1"  =~ [^[:space:]] ]] &&              echo "$HELP_ENVS"     >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ module      ]] && echo "$HELP_MODULE"  >> $FILE
  [[       $HELP_MESSAGE_INC =~ message     ]] && echo "$HELP_MESSAGE" >> $FILE
  [[ ${AUTO_HELP_INC[@]}     =~ version     ]] && echo "$HELP_VERSION" >> $FILE
 
  [[ $provided_help == yes ]] && cat $HELP_EVALD_FILE                  >> $FILE
 
  if [[ $FLAVOR == "lmod" ]]; then
    echo "]] "                                                         >> $FILE
  else
    echo "  }"                                                         >> $FILE
    echo "} "                                                          >> $FILE
  fi
  echo ""                                                              >> $FILE

  #v--INCLUDE module() array
                  # Include module array content
  for i in "${module[@]}"; do
     echo $i             >> $FILE
  done
  echo ""                >> $FILE

  #if [[ "$ENV_KEY" =~ [^[:space:]]  ]]; then
  #   env_key=($ENV_KEY)
  #   env_val=($ENV_VAL)
  #   for i in `seq 0 $((${#env_key[@]}-1))`; do
  #      echo "setenv( \"${env_key[$i]}\",  \"${env_val[$i]}\" )" >> $FILE
  #   done
  #fi

  #v--ENV
                  # Include user-defined environment variables
  for i in `seq 1 30`; do
    env=$( eval echo \"\$ENV$i\" )
    if [[  "$env"  =~ [^[:space:]] ]]; then
       IFS='= ' read -r key val <<< "$env"
                       if [[ $FAVOR == "lmod" ]]; then
                        echo "setenv( \"${key}\",  \"${val}\" )" >> $FILE
                       else
                        echo "setenv ${key} ${val}"              >> $FILE
                       fi
       HELP_ENV_KEY+=(${key})
       HELP_ENV_VAL+=(${val})
    fi
  done

  #v--CMDS

  [[ $ENV1 =~ [^[:space:]] ]] && echo ""                >> $FILE

                  # Include user-defined (custom) LUA commands
  for i in `seq 1 30`; do
    cmd=$( eval echo \"\$CMD$i\" )
    [[  "$cmd"  =~ [^[:space:]] ]] &&               echo "$cmd" >> $FILE
  done

  [[ $CMD1 =~ [^[:space:]] ]] && echo ""                >> $FILE


  if [[ ! "$MKMOD_DEBUG"  =~ [^[:space:]]  ]]; then
     echo "  -> Finished creating and installing the modulefile for $NAME_cap."
     echo ""
  else
     echo "  ->> MKMOD_DEBUG: Printing expected modulefile without creating it."
     cat /tmp/${USER}_${MODULE}_$$
     rm  /tmp/${USER}_${MODULE}_$$
  fi

# # END NOW (finally) INSERT  appropriate content into the module file ($FILE)

# ^-- CREATE MODULE

  rm -f $MODULEFILE_EVALD_FILE $HELP_EVALD_FILE $WHATIS_EVALD_FILE


#############END--^      CREATE MODULEFILE
  
  
#############BEG--v      GROUP ACCESS REQUEST
  
  if [[ $GROUP_ACCESS =~ [^[:space:]] ]]; then
  
     echo ""
     echo "  -> GROUP_ACCESS variable is set.  Will allow group access to modulefile."
     echo ""
   
                          # Determine which group to use
     if [[ ! $GROUP =~ [^[:space:]] ]]; then
  
                          # Use the primary group
        GROUP=`id -gn`
        group_type="primary"
        do_chgrp=no
     else
                          # User supplied Group, make sure all it is valid
        touch /tmp/imod_test.$$
        chgrp_out=`chgrp $GROUP /tmp/imod_test.$$ 2>&1`
        if [[ $? != 0 ]]; then
           do_chgrp=no
           echo "  -> WARNING: test for changing group to $GROUP failed."
           echo "  ->          CHANGE to $GROUP will NOT be performed."
           echo "  ->          chgrp output: $chgrp_out"
           #USUAL ERROR: chgrp: changing group of /tmp/imod_test....: Operation not permitted
        else
           echo "  -> Test for changing group to $GROUP passed."
           do_chgrp=yes
        fi
        rm -rf  /tmp/imod_test.$$
  
        do_chgrp=yes
        group_type="user-supplied (in GROUP variable)"
     fi
   
   
     getent_out=`getent group $GROUP`
     group_users=`echo $getent_out | sed 's/.*://'`
     echo "  -> Processing GROUP access for $group_type group $GROUP"
     echo "  -> Members of the group are: $group_users"
     echo ""
   
     do_chmod=yes
     if [[ $MODULEFILES_DIR =~  $STOCKYARD ]]; then
        CHANGE_DIRS=(  $STOCKYARD )
        CHANGE_DIRS+=( $WORK )
        BASE_DIR=$WORK
     elif [[ $MODULEFILES_DIR =~  $HOME ]]; then
        CHANGE_DIRS+=( $HOME )
        BASE_DIR=$HOME
     else
        echo "  -> GROUP ACCESS to a directory outside of \$HOME or \$WORK is not allowed."
        echo "  ->     Your modulefiles path is $MODULEFILES_DIR"
        echo "  ->     Group permissions will not be changed to provide group access."
        do_chmod=no
     fi
  
     if [[ $do_chmod == yes ]]; then
        RELATIVE_PATH=`echo $MODULEFILES_DIR | sed 's@'$BASE_DIR'/@@'`
        
        IFS='/' read -r -a dirs <<< "$RELATIVE_PATH"
     
        DIR=$BASE_DIR
        for dir in ${dirs[@]}; do
            DIR=$DIR/$dir
            CHANGE_DIRS+=( $DIR )
        done
     
        CHANGE_DIRS+=( $MODULEFILES_DIR/$MODULE_DIR )
        CHANGE_DIRS+=( $MODULEFILES_DIR/$MODULE_DIR/$MODULE )
  
                         #Now process all directories in the array.
        if [[ $do_chgrp == yes ]]; then
            echo "  -> chmod g+rX  and chgrp $GROUP  executed on: "
        else
            echo "  -> chmod g+rX  executed on: "
        fi
        for change_dir in ${CHANGE_DIRS[@]}; do
          echo "  ->    $change_dir"
         $CMD chmod g+rX $change_dir
          if [[ $do_chgrp == yes ]]; then
             $CMD chgrp $GROUP $change_dir
          fi
        done
  
     fi
    #echo ""
  fi

#############END--^      GROUP ACCESS REQUEST



#############BEG--v      CHECK FOR LOGIN SHELL
#                                    Let's find the login shell
#                                    or use $SHELL as the login shell
  echo $'\n'"  -> LOGIN SHELL DETERMINATION:"
  supported_shells=(csh tcsh bash zsh)
  
  LOGIN_SHELL="not_found"
  ln_shell_by="from MKMOD_LOGIN_SHELL var, or SHELL var, or finger"
  my_login_shell=""
  
  if [[ $MKMOD_LOGIN_SHELL =~ [^[:space:]] ]]; then
     LOGIN_SHELL=$MKMOD_LOGIN_SHELL
     ln_shell_by="by MKMOD_LOGIN_SHELL var"
  else
     finger -m $USER 2>&1 |grep Shell:  2>&1|sed  's/.*Shell:\s*\([a-z,\/]*\)/\1/' 2>&1  > /dev/null
     if [[ ! ${PIPESTATUS[@]} =~ 1 ]]; then
        LOGIN_SHELL=`finger -m $USER |grep Shell: |sed  's/.*Shell:\s*\([a-z,\/]*\)/\1/'`
        ln_shell_by="by finger"
     else
        if [[ $SHELL  =~ [^[:space:]] ]]; then
           LOGIN_SHELL=$SHELL
           ln_shell_by="by SHELL var"
        fi
     fi
  fi
  
  for shell in ${supported_shells[@]} ; do
     [[ $LOGIN_SHELL =~ $shell ]] && my_login_shell=$shell
  done
  
  #           no determined value                           not set
  if [[ $LOGIN_SHELL =~ not_found ]] && [[ ! $MKMOD_LOGIN_SHELL =~ [^[:space:]] ]]; then
     echo "  -> INTERNAL ERROR: Could not determine login shell."
     echo "  ->                 Please set MKMOD_LOGIN_SHELL"
     echo "  ->                 to your login shell (e.g. bash,tcsh, etc)."
     exit
  fi
  
  if [[ ! $my_login_shell =~ [^[:space:]] ]]; then
     echo "  -> ERROR: Login shell \"$LOGIN_SHELL\" as determined $ln_shell_by"
     echo "  ->        was not found to be one of supported shells (${supported_shells[@]})."
     exit
  fi
  
  echo "  -> As determined $ln_shell_by, $my_login_shell is assumed to be your login shell."
  [[ ! $MKMOD_LOGIN_SHELL =~ [^[:space:]] ]] &&
       echo "  ->    This can be changed by setting your shell in MKMOD_LOGIN_SHELL."
  
#############END--^      CHECK FOR LOGIN SHELL


#############BEG--v      MODULE USE IN SHELLRC
#                                    Check for "module use $MODULEFILE_DIR" in SHELLRC
#                                    Insert if not found, and logic to execute just once
#                                    bash, csh, tcsh and zsh supported

  if [[ ! "$MKMOD_DEBUG"  =~ [^[:space:]]  ]] && [[ ! "$USE_IN_SHELLRC"  =~ none  ]] ; then
     echo $'\n'"  -> MODULE USE in SHELLRC FILE:"
 
     [[ $my_login_shell =~ bash ]] && shellrc=.bashrc SHELLRC=$HOME/.bashrc  RC=BASHRC
     [[ $my_login_shell =~  zsh ]] && shellrc=.zshenv SHELLRC=$HOME/.zshenv  RC=ZSHRC
     [[ $my_login_shell =~  csh ]] && shellrc=.cshrc  SHELLRC=$HOME/.cshrc   RC=CSHRC

     echo "  -> Checking for \"module use $MODULEFILES_DIR\" in \$HOME/$shellrc."
 
     new_shellrc_file=no
     if [[ ! -e $SHELLRC ]]; then
        echo "  -> Creating $SHELLRC for locating the \"module use \$MODULEFILE_DIR\" command."
        touch $SHELLRC
        new_shellrc_file=yes
     fi

     grep -e  "$MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT" $SHELLRC >/dev/null
  
     if [[ $? == 0 ]]; then

        echo "  -> Note: \"module use $MODULEFILES_DIR\" is already in \$HOME/$shellrc."
        chx4="checking for "

     else  #beg do RC insert

        chx4=""
        echo "  -> Note: Including \"module use $MODULEFILES_DIR\"  in \$HOME/$shellrc."
        cp $SHELLRC                     ${SHELLRC}_mkmod_bu.$$
  
        echo $'\n'"  -> ********************************************************************"$'\n'
        if [[ $new_shellrc_file == no ]]; then
           echo $'\n'"  -> MAKING $shellrc BACKUP \$HOME/${shellrc}_mkmod_bu.$$."$'\n'
           cp              $SHELLRC                      ${SHELLRC}_mkmod_bu.$$
        fi
        echo      "  -> DON'T FORGET TO LOGOUT and LOGIN to activate "module use " in $shellrc"
        echo $'\n'"  -> ********************************************************************"$'\n'
  
#       v-- USE TACC sections of RC file
        at_tacc=1
        if [[ $my_login_shell == bash ]] ; then
           grep -P '^\s*export\s+__'$RC'_SOURCED__=1' $SHELLRC > /dev/null
           at_tacc=$?
        fi
        if [[ $my_login_shell =~ csh ]]; then
          grep -P '^\s*setenv\s+__'$RC'_SOURCED__ 1' $SHELLRC > /dev/null
          at_tacc=$?
        fi
#       ^-- SPECIAL FOR TACC

        if [[ $at_tacc == 0 ]]; then   #This is a TACC Convention
      #                                            Insert Module Use after SHELLRC_SOURCED|CSHRC_SOURED if it exists
      #                                            include 4 spaces in front
            [[ $my_login_shell == bash ]] && 
               sed -i '/export __'$RC'_SOURCED__=1/a'"\ \ \ \ module use $MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT" $SHELLRC
            [[ $my_login_shell =~ csh ]]  &&
               sed -i '/setenv __'$RC'_SOURCED__ 1/a'"\ \ \ \ module use $MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT" $SHELLRC
   
        else  # non-TACC INSERT (or zsh at TACC)
   
          #                                            Otherwise, put the module use at the end
          #                                            Make sure it is only sourced (used) once at login
          #                                            and not in batch
      
          if [[ $my_login_shell == bash ]] || [[ $my_login_shell == zsh ]] ; then 
             readarray message <<-EOF
                :
                :###############
                :# SECTION MKMOD
                :if [ -z "\$__MKMOD_${RC}_SOURCED__" -a "\$ENVIRONMENT" != BATCH ]; then
                :  export   __MKMOD_${RC}_SOURCED__=1
                :  module use $MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT
                :fi
	EOF
               #Above EOF must have a tab before it, and nothing else (NO SPACES, just a tab)!
       
                                   #lop off spaces up to and including ":", and print
                shopt -s extglob
                printf '%s' "${message[@]#+( ):}" >> $SHELLRC
                shopt -u extglob
          fi
     
          if [[ $my_login_shell =~ csh ]] ; then
             readarray message <<-EOF
                :
                :###############
                :# SECTION MKMOD
                :if (  ! \$?__MKMOD_${RC}_SOURCED__ && ! \$?ENVIRONMENT )  then
                :  setenv   __MKMOD_${RC}_SOURCED__ 1
                :  module use $MODULEFILES_DIR #MKMOD_KEEP_THIS_COMMENT
                :endif
	EOF
               #Above EOF must have a tab before it, and nothing else (NO SPACES, just a tab)!
     
                                   #lop off spaces up to and including ":", and print
                shopt -s extglob
                printf '%s' "${message[@]#+( ):}" >> $SHELLRC
                shopt -u extglob
          fi 
   
        fi #end non-TACC INSER

  
     fi  #end of do RC insert
     echo "  -> Finished with $chx4 \"module use\" setup in \$HOME/$shellrc"
     echo ""
  fi
#############END--^      MODULE USE IN SHELLRC

#https://stackoverflow.com/questions/6676568/how-to-print-in-a-tabular-format-in-tcl
